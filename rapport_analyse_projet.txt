================================================================================
                    RAPPORT D'ANALYSE DU PROJET GAME OF LIFE
                           Devoir des Rois Mages (Q54)
================================================================================

Auteur de l'analyse : Gianluca Tiengo et Safwan Hannoudi
Date : 15 janvier 2026

================================================================================
                    PARTIE 1 : CONFORMITE AUX CONSIGNES
================================================================================

------------------------------------------------------------------------------
1. FICHIERS A RENDRE
------------------------------------------------------------------------------

   CONSIGNE : Fournir les fichiers liveview.py, livemodel.py, livecontroller.py,
              livecounter.py, main.py

   STATUT : [OK] CONFORME

   FICHIERS PRESENTS :
   - liveview.py      : Toutes les classes 'view' (LiveView, LiveCanvas,
                        LiveCommandBar)
   - livemodel.py     : Toutes les classes 'model' (LiveModel, LiveCell,
                        Observer, Observable, ConfigurationStrategy, etc.)
   - livecontroller.py: Classe LiveController
   - livecounter.py   : Classe LiveCounter pour les statistiques
   - main.py          : Point d'entree minimal de l'application

------------------------------------------------------------------------------
2. ARCHITECTURE MVC
------------------------------------------------------------------------------

   CONSIGNE : Developper le jeu en POO sous architecture MVC. LiveModel avec
              indices standards (0, 1, 2...), LiveView avec matrice pixelisee.

   STATUT : [OK] CONFORME

   LOCALISATION DANS LE CODE :

   a) LiveModel utilise des indices standards (0, 1, 2...) :
      - livemodel.py:339-352    -> __init__ de LiveModel
      - livemodel.py:659-669    -> __create_grid() avec indices standards
      - livemodel.py:671-702    -> __count_neighbors() utilise row/col directs

   b) LiveView utilise des coordonnees en pixels (0, 10, 20...) :
      - liveview.py:211-229     -> __model_to_canvas() conversion indices->pixels
      - liveview.py:231-247     -> __canvas_to_model() conversion pixels->indices
      - liveview.py:39-41       -> __cell_size stocke la taille en pixels

   c) Separation des responsabilites MVC :
      - Model (livemodel.py)    -> Logique du jeu, pas de GUI
      - View (liveview.py)      -> Affichage, pas de logique metier
      - Controller (livecontroller.py) -> Coordination Model/View

------------------------------------------------------------------------------
3. INTERFACE UTILISATEUR - MODIFICATION DES COULEURS
------------------------------------------------------------------------------

   CODE EXISTANT
   - liveview.py:56-65  -> Dictionnaire __colors avec les couleurs par defaut

------------------------------------------------------------------------------
4. CANVAS - DESIGN PATTERN ITERATOR
------------------------------------------------------------------------------

   CONSIGNE : Implanter l'iteration de sortie avec le design pattern Iterator
              applique a LiveCanvas.

   STATUT : [OK] CONFORME

   LOCALISATION DANS LE CODE :
   - liveview.py:249-264  -> __grid_iterator() : Generateur Python (yield)
                             Implementation du pattern Iterator
   - liveview.py:175-196  -> display_grid() utilise __grid_iterator()
                             pour parcourir la grille

   EXTRAIT DU CODE :
   ```python
   def __grid_iterator(self, grid):
       """ITERATOR PATTERN: Generator that yields all cells..."""
       for row in range(len(grid)):
           for col in range(len(grid[row])):
               yield (row, col, grid[row][col])
   ```

------------------------------------------------------------------------------
5. STRATEGIE - CONFIGURATION ALEATOIRE
------------------------------------------------------------------------------

   CONSIGNE : Proposer une configuration aleatoire (25% cellules vivantes),
              bouton 'Alea' a cote de 'Canon'. Bonus: design pattern Strategy.

   STATUT : [OK] CONFORME (avec bonus Strategy Pattern)

   LOCALISATION DANS LE CODE :

   a) Configuration aleatoire 25% :
      - livemodel.py:596-612    -> set_random_configuration(alive_percentage=0.25)
      - livecontroller.py:120-126 -> on_random() appelle avec 0.25

   b) Bouton 'Random' (equivalent de 'Alea') :
      - livecontroller.py:196   -> command_bar.create_button("Random", ...)
      - livecontroller.py:197   -> command_bar.create_button("Cannon", ...)
      REMARQUE : Le bouton s'appelle "Random" au lieu de "Alea" comme suggere

   c) BONUS - Design Pattern Strategy :
      - livemodel.py:83-98      -> ConfigurationStrategy (classe abstraite)
      - livemodel.py:101-112    -> EmptyStrategy
      - livemodel.py:115-137    -> RandomStrategy (avec alive_percentage)
      - livemodel.py:140-175    -> CannonStrategy (Gosper Glider Gun)
      - livemodel.py:563-579    -> apply_configuration_strategy() methode

------------------------------------------------------------------------------
6. FONCTIONNALITES SUPPLEMENTAIRES - COULEURS SELON VOISINS
------------------------------------------------------------------------------

   CONSIGNE : Afficher les cellules avec des couleurs differentes suivant
              le nombre de voisins.

   STATUT : [OK] CONFORME

   LOCALISATION DANS LE CODE :

   a) Definition des couleurs :
      - liveview.py:56-65       -> Dictionnaire des couleurs :
        * 'color_initial'       -> Gris (#888888) - etat initial
        * 'color_newly_born'    -> Vert (#44DD44) - cellule nouvellement nee
        * 'color_long_lived'    -> Bleu (#4444FF) - cellule stable (age >= 2)
        * 'color_will_die'      -> Rouge (#FF4444) - cellule qui va mourir
        * 'color_born_and_die'  -> Jaune (#FFDD44) - cellule ephemere

   b) Logique de determination des couleurs :
      - liveview.py:138-167     -> draw_cell() determine la couleur selon:
        * is_newly_born et will_die_next_gen -> Jaune
        * is_newly_born -> Vert
        * will_die_next_gen -> Rouge
        * is_long_lived -> Bleu
        * sinon -> Gris (initial)

   c) Calcul du destin des cellules :
      - livemodel.py:519-555    -> Dans evolve(), calcul des flags:
        * is_newly_born (ligne 533)
        * is_long_lived (lignes 538-539)
        * will_die_next_gen (lignes 550-555)

================================================================================
                    PARTIE 2 : CONFORMITE AUX CRITERES D'EVALUATION
================================================================================

------------------------------------------------------------------------------
7. ATTRIBUTS ET METHODES PRIVES
------------------------------------------------------------------------------

   STATUT : [OK] CONFORME

   EXEMPLES :
   - livemodel.py:197-204     -> Attributs prives de LiveCell (__state, __age...)
   - livemodel.py:347-352     -> Attributs prives de LiveModel (__width, __grid...)
   - liveview.py:39-53        -> Attributs prives de LiveCanvas (__width, __canvas...)
   - livecontroller.py:38-48  -> Attributs prives de LiveController

   REMARQUE : Tous les attributs utilisent le prefixe __ (name mangling Python)

------------------------------------------------------------------------------
8. COMPOSITION ET AGREGATION
------------------------------------------------------------------------------

   STATUT : [OK] CONFORME

   LOCALISATION :

   a) COMPOSITION - La grille est un ensemble de cellules :
      - livemodel.py:350       -> self.__grid = []  (liste de LiveCell)
      - livemodel.py:659-669   -> __create_grid() cree les objets LiveCell

   b) AGREGATION - Le jeu est un ensemble d'objets :
      - liveview.py:363-366    -> LiveView contient LiveCanvas et LiveCommandBar
      - livecontroller.py:38-40 -> Controller contient Model, View, Counter

------------------------------------------------------------------------------
9. HERITAGE ET POLYMORPHISME
------------------------------------------------------------------------------

   STATUT : [OK] CONFORME

   LOCALISATION :

   a) Classes abstraites avec ABC :
      - livemodel.py:21-36     -> Observer (classe abstraite)
      - livemodel.py:39-71     -> Observable (classe abstraite)
      - livemodel.py:83-98     -> ConfigurationStrategy (classe abstraite)

   b) Heritage :
      - livemodel.py:301       -> LiveModel(Observable) herite de Observable
      - livecontroller.py:17   -> LiveController(Observer) herite de Observer
      - livemodel.py:101-175   -> EmptyStrategy, RandomStrategy, CannonStrategy
                                  heritent de ConfigurationStrategy

   c) Polymorphisme :
      - livemodel.py:563-579   -> apply_configuration_strategy() accepte toute
                                  strategie (polymorphisme)

------------------------------------------------------------------------------
10. DESIGN PATTERNS
------------------------------------------------------------------------------

   STATUT : [OK] CONFORME - Plusieurs patterns implementes

   a) OBSERVER PATTERN :
      - livemodel.py:21-71     -> Interface Observer/Observable
      - livemodel.py:387-414   -> Implementation dans LiveModel
      - livecontroller.py:62-75 -> Controller observe le Model

   b) STRATEGY PATTERN :
      - livemodel.py:83-175    -> ConfigurationStrategy et implementations
      - livemodel.py:563-579   -> apply_configuration_strategy()

   c) SINGLETON PATTERN :
      - livemodel.py:318       -> __instance = None
      - livemodel.py:320-337   -> singleton() methode de classe

   d) ITERATOR PATTERN :
      - liveview.py:249-264    -> __grid_iterator() generateur

------------------------------------------------------------------------------
11. ORDONNANCEMENT DES ATTRIBUTS ET METHODES
------------------------------------------------------------------------------

   STATUT : [PARTIELLEMENT CONFORME]

   ORDRE REQUIS PAR LE PROFESSEUR :
   1. Attributs de classe
   2. Methodes de classe (@classmethod)
   3. Methodes de creation (singleton, factory, __new__)
   4. Constructeur (__init__)
   5. Destructeur (__del__)
   6. Autres methodes magiques (__str__, __next__...)
   7. Accesseurs (properties)
   8. Methodes publiques
   9. Methodes protegees
   10. Methodes privees

   ANALYSE PAR CLASSE :

   LiveModel (livemodel.py:301-711) :
   - [OK] Attribut de classe __instance (ligne 318)
   - [OK] Methode de classe singleton() (lignes 320-337)
   - [OK] Constructeur __init__ (lignes 339-352)
   - [OK] Methode magique __str__ (lignes 354-361)
   - [OK] Accesseurs @property (lignes 363-381)
   - [OK] Methodes publiques (lignes 387-612)
   - [OK] Methodes privees (lignes 659-711)

   LiveCell (livemodel.py:182-298) :
   - [OK] Constructeur __init__ (lignes 190-204)
   - [OK] Methode magique __str__ (lignes 206-208)
   - [OK] Accesseurs @property (lignes 210-298)
   - REMARQUE : Pas de methodes publiques/privees additionnelles

   LiveCanvas (liveview.py:16-264) :
   - [AMELIORABLE] __str__ manquant
   - [OK] Constructeur __init__ (lignes 29-65)
   - [OK] Accesseurs @property (lignes 67-75)
   - [OK] Methodes publiques (lignes 77-205)
   - [OK] Methodes privees (lignes 211-264)

------------------------------------------------------------------------------
12. PAS DE VARIABLES GLOBALES DANS LES CLASSES
------------------------------------------------------------------------------

   STATUT : [OK] CONFORME

   VERIFICATION :
   - main.py:29-32            -> Variables de configuration locales a main()
   - Toutes les classes recoivent leurs dependances par arguments
   - Aucune reference a des variables globales dans les classes

------------------------------------------------------------------------------
13. ACCESSEURS AVEC DECORATEURS
------------------------------------------------------------------------------

   STATUT : [OK] CONFORME

   EXEMPLES :
   - livemodel.py:210-218     -> @property et @state.setter pour LiveCell.state
   - livemodel.py:363-381     -> @property pour LiveModel (width, height, etc.)
   - liveview.py:67-75        -> @property pour LiveCanvas (canvas, cell_size)
   - livecounter.py:34-57     -> @property pour LiveCounter

------------------------------------------------------------------------------
14. METHODES MAGIQUES
------------------------------------------------------------------------------

   STATUT : [OK] CONFORME

   UTILISATION :
   - livemodel.py:206-208     -> LiveCell.__str__()
   - livemodel.py:354-361     -> LiveModel.__str__()
   - livecounter.py:59-70     -> LiveCounter.__str__()

   REMARQUE : __next__ n'est pas utilise car le pattern Iterator est
              implemente via un generateur (yield) plutot qu'une classe
              iterator separee

------------------------------------------------------------------------------
15. TESTS UNITAIRES
------------------------------------------------------------------------------

   STATUT : [OK] CONFORME

   LOCALISATION :
   - livemodel.py:715-741     -> Tests de LiveModel (if __name__ == "__main__")
   - liveview.py:445-472      -> Tests de LiveView
   - livecontroller.py:261-284 -> Tests de LiveController
   - livecounter.py:156-174   -> Tests de LiveCounter

================================================================================
                    PARTIE 3 : AMELIORATIONS POSSIBLES
================================================================================


------------------------------------------------------------------------------
A. AMELIORATIONS DE QUALITE DE CODE
------------------------------------------------------------------------------

3. AJOUTER __str__ A LiveCanvas ET LiveView [PRIORITE BASSE]

   Probleme : Ces classes n'ont pas de methode __str__ pour le debogage

   Fichiers : liveview.py

   Exemple pour LiveCanvas :
   ```python
   def __str__(self):
       return f"LiveCanvas({self.__width}x{self.__height}, cell_size={self.__cell_size})"
   ```

4. IMPLEMENTER __iter__ ET __next__ POUR L'ITERATOR [OPTIONNEL]

   Probleme : Le pattern Iterator est implemente via un generateur (pythonique)
              mais pourrait etre implemente avec __iter__/__next__ pour
              correspondre exactement au pattern classique.

   Note : L'implementation actuelle avec yield est correcte et plus pythonique.
          Cette modification serait pour des raisons pedagogiques uniquement.

5. AJOUTER DES DOCSTRINGS AUX METHODES PROTEGEES [PRIORITE BASSE]

   Fichiers concernes : Toutes les methodes commencant par _ (un seul underscore)
   Note : Les methodes privees (__) ont deja des docstrings

6. SEPARER LES DESIGN PATTERNS DANS DES FICHIERS SEPARES [OPTIONNEL]

   Structure actuelle : Tout dans livemodel.py
   Structure proposee :
   - patterns/observer.py : Observer, Observable
   - patterns/strategy.py : ConfigurationStrategy et implementations

   Avantage : Meilleure modularite et reutilisabilite


================================================================================
                    PARTIE 4 : RESUME
================================================================================

CONFORMITE GLOBALE : 90%

POINTS CONFORMES (9/10) :
[OK] Fichiers a rendre
[OK] Architecture MVC
[OK] Iterator Pattern sur Canvas
[OK] Configuration aleatoire 25%
[OK] Bouton Random/Alea
[OK] Strategy Pattern (bonus)
[OK] Couleurs selon voisins
[OK] Attributs/methodes prives
[OK] Design patterns multiples


POINTS D'ATTENTION :
- Les patterns Iterator et Strategy sont bien implementes
- Observer Pattern correctement utilise pour la synchronisation Model/View
- Singleton Pattern present mais non utilise dans main.py

================================================================================
                              FIN DU RAPPORT
================================================================================
