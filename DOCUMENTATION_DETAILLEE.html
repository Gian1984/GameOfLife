<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <title>Game of Life - Documentation Synthetique des Concepts POO</title>
    <style>
        body {
            font-family: 'Times New Roman', serif;
            line-height: 1.6;
            max-width: 210mm;
            margin: 0 auto;
            padding: 15mm;
            color: #000;
            background: white;
        }
        h1 {
            color: #0066cc;
            border-bottom: 3px solid #0066cc;
            padding-bottom: 8px;
            font-size: 20pt;
            text-align: center;
        }
        h2 {
            color: #0066cc;
            border-bottom: 2px solid #0066cc;
            padding-bottom: 5px;
            margin-top: 25px;
            font-size: 14pt;
        }
        h3 {
            color: #0088cc;
            margin-top: 15px;
            font-size: 12pt;
        }
        .concept {
            background: #f0f8ff;
            border: 2px solid #4a90e2;
            padding: 12px;
            margin: 12px 0;
            border-radius: 5px;
            page-break-inside: avoid;
        }
        .pattern {
            background: #d4edda;
            border-left: 4px solid #28a745;
            padding: 12px;
            margin: 12px 0;
            page-break-inside: avoid;
        }
        .localisation {
            background: #fff3cd;
            border-left: 4px solid #ff9800;
            padding: 10px;
            margin: 10px 0;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
        }
        code {
            background: #f4f4f4;
            padding: 2px 5px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
        }
        pre {
            background: #f8f8f8;
            border: 1px solid #ddd;
            border-left: 4px solid #0066cc;
            padding: 10px;
            overflow-x: auto;
            font-family: 'Courier New', monospace;
            font-size: 0.8em;
            margin: 10px 0;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 10px 0;
            font-size: 0.9em;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: left;
        }
        th {
            background: #0066cc;
            color: white;
        }
        .header-info {
            text-align: center;
            margin-bottom: 20px;
            font-size: 11pt;
        }
        @media print {
            body { padding: 10mm; }
            .concept, .pattern { page-break-inside: avoid; }
        }
    </style>
</head>
<body>

<h1>Game of Life - Documentation des Concepts POO</h1>

<div class="header-info">
    <strong>Projet Q54 - Devoir des Rois Mages</strong><br>
    Auteurs : Gianluca Tiengo et Safwan Hannoudi<br>
    Date : Janvier 2026
</div>

<!-- ========================================== -->
<h2>1. Architecture MVC (Model-View-Controller)</h2>
<!-- ========================================== -->

<div class="concept">
    <h3>Explication technique</h3>
    <p>Le pattern MVC separe l'application en trois couches independantes : le <strong>Model</strong> gere les donnees et la logique metier, la <strong>View</strong> gere l'affichage, et le <strong>Controller</strong> coordonne les interactions entre les deux. Cette separation permet une meilleure maintenabilite et testabilite du code.</p>
</div>

<div class="localisation">
    <strong>Localisation dans le code :</strong><br>
    - <code>livemodel.py</code> : Classe <code>LiveModel</code> (lignes 301-711) - Logique du jeu<br>
    - <code>liveview.py</code> : Classes <code>LiveView</code>, <code>LiveCanvas</code>, <code>LiveCommandBar</code> - Interface graphique<br>
    - <code>livecontroller.py</code> : Classe <code>LiveController</code> (lignes 17-285) - Coordination
</div>

<pre>
# main.py - Instanciation MVC (lignes 34-44)
model = LiveModel(width=GRID_WIDTH, height=GRID_HEIGHT)
view = LiveView(title=WINDOW_TITLE)
controller = LiveController(model, view)
</pre>

<!-- ========================================== -->
<h2>2. Encapsulation - Attributs et Methodes Prives</h2>
<!-- ========================================== -->

<div class="concept">
    <h3>Explication technique</h3>
    <p>L'encapsulation protege les donnees internes d'une classe en les rendant privees (prefixe <code>__</code> en Python). L'acces se fait via des accesseurs (<code>@property</code>). Cela garantit l'integrite des donnees et permet de modifier l'implementation sans affecter le code client.</p>
</div>

<div class="localisation">
    <strong>Localisation dans le code :</strong><br>
    - <code>livemodel.py:197-204</code> : Attributs prives de <code>LiveCell</code><br>
    - <code>livemodel.py:347-352</code> : Attributs prives de <code>LiveModel</code><br>
    - <code>liveview.py:39-53</code> : Attributs prives de <code>LiveCanvas</code>
</div>

<pre>
# livemodel.py - LiveCell (lignes 197-204)
def __init__(self, state=False):
    self.__state = state           # Attribut prive
    self.__previous_state = False
    self.__neighbors_count = 0
    self.__age = 0

# Accesseur avec @property (lignes 210-218)
@property
def state(self):
    return self.__state

@state.setter
def state(self, value):
    self.__state = value
</pre>

<!-- ========================================== -->
<h2>3. Composition</h2>
<!-- ========================================== -->

<div class="concept">
    <h3>Explication technique</h3>
    <p>La composition est une relation "contient" forte ou un objet est compose d'autres objets qui ne peuvent exister independamment. Dans notre cas, la grille (<code>LiveModel</code>) est composee de cellules (<code>LiveCell</code>) - si le modele est detruit, les cellules le sont aussi.</p>
</div>

<div class="localisation">
    <strong>Localisation dans le code :</strong><br>
    - <code>livemodel.py:350</code> : <code>self.__grid = []</code> - Liste de LiveCell<br>
    - <code>livemodel.py:659-669</code> : <code>__create_grid()</code> cree les objets LiveCell<br>
    - <code>liveview.py:363-366</code> : LiveView contient LiveCanvas et LiveCommandBar
</div>

<pre>
# livemodel.py - Creation de la grille (lignes 659-669)
def __create_grid(self):
    self.__grid = []
    for row in range(self.__height):
        row_cells = []
        for col in range(self.__width):
            row_cells.append(LiveCell(state=False))  # Composition
        self.__grid.append(row_cells)
</pre>

<!-- ========================================== -->
<h2>4. Heritage et Classes Abstraites</h2>
<!-- ========================================== -->

<div class="concept">
    <h3>Explication technique</h3>
    <p>L'heritage permet a une classe enfant d'heriter des attributs et methodes d'une classe parent. Les classes abstraites (via <code>ABC</code>) definissent une interface que les classes enfants doivent implementer, garantissant un contrat commun.</p>
</div>

<div class="localisation">
    <strong>Localisation dans le code :</strong><br>
    - <code>livemodel.py:21-36</code> : Classe abstraite <code>Observer</code><br>
    - <code>livemodel.py:39-71</code> : Classe abstraite <code>Observable</code><br>
    - <code>livemodel.py:83-98</code> : Classe abstraite <code>ConfigurationStrategy</code><br>
    - <code>livemodel.py:301</code> : <code>LiveModel(Observable)</code><br>
    - <code>livecontroller.py:17</code> : <code>LiveController(Observer)</code>
</div>

<pre>
# livemodel.py - Classe abstraite Observer (lignes 21-36)
from abc import ABC, abstractmethod

class Observer(ABC):
    @abstractmethod
    def update(self, subject):
        pass

# Heritage - LiveModel herite de Observable (ligne 301)
class LiveModel(Observable):
    ...
</pre>

<!-- ========================================== -->
<h2>5. Design Pattern : Observer</h2>
<!-- ========================================== -->

<div class="pattern">
    <h3>Explication technique</h3>
    <p>Le pattern Observer definit une relation un-a-plusieurs : quand le sujet (Observable) change d'etat, tous ses observateurs sont notifies automatiquement. Ici, le <code>LiveModel</code> notifie le <code>LiveController</code> a chaque modification de la grille.</p>
</div>

<div class="localisation">
    <strong>Localisation dans le code :</strong><br>
    - <code>livemodel.py:21-71</code> : Interfaces Observer/Observable<br>
    - <code>livemodel.py:387-414</code> : Implementation dans LiveModel (<code>attach</code>, <code>detach</code>, <code>notify_observers</code>)<br>
    - <code>livecontroller.py:43</code> : <code>self.__model.attach(self)</code><br>
    - <code>livecontroller.py:63-74</code> : Methode <code>update()</code> du Controller
</div>

<pre>
# livemodel.py - Notification des observateurs (lignes 407-414)
def notify_observers(self):
    for observer in self.__observers:
        observer.update(self)

# livecontroller.py - Reception de la notification (lignes 63-74)
def update(self, subject):
    self.__update_display()  # Rafraichit l'affichage
</pre>

<!-- ========================================== -->
<h2>6. Design Pattern : Strategy</h2>
<!-- ========================================== -->

<div class="pattern">
    <h3>Explication technique</h3>
    <p>Le pattern Strategy permet de definir une famille d'algorithmes interchangeables. Chaque strategie encapsule un algorithme specifique. Le client peut changer de strategie a l'execution sans modifier son code.</p>
</div>

<div class="localisation">
    <strong>Localisation dans le code :</strong><br>
    - <code>livemodel.py:83-98</code> : Classe abstraite <code>ConfigurationStrategy</code><br>
    - <code>livemodel.py:101-112</code> : <code>EmptyStrategy</code> - Vide la grille<br>
    - <code>livemodel.py:115-137</code> : <code>RandomStrategy</code> - Configuration aleatoire 25%<br>
    - <code>livemodel.py:140-175</code> : <code>CannonStrategy</code> - Gosper Glider Gun<br>
    - <code>livemodel.py:563-579</code> : <code>apply_configuration_strategy()</code>
</div>

<pre>
# livemodel.py - Strategy Pattern (lignes 83-137)
class ConfigurationStrategy(ABC):
    @abstractmethod
    def apply(self, model):
        pass

class RandomStrategy(ConfigurationStrategy):
    def __init__(self, alive_percentage=0.25):
        self.__alive_percentage = alive_percentage

    def apply(self, model):
        for row in range(model.height):
            for col in range(model.width):
                if random.random() < self.__alive_percentage:
                    model.grid[row][col].state = True
</pre>

<!-- ========================================== -->
<h2>7. Design Pattern : Singleton</h2>
<!-- ========================================== -->

<div class="pattern">
    <h3>Explication technique</h3>
    <p>Le pattern Singleton garantit qu'une classe n'a qu'une seule instance et fournit un point d'acces global. Utile pour des ressources partagees comme une configuration ou un modele de donnees unique.</p>
</div>

<div class="localisation">
    <strong>Localisation dans le code :</strong><br>
    - <code>livemodel.py:318</code> : Attribut de classe <code>__instance = None</code><br>
    - <code>livemodel.py:320-337</code> : Methode de classe <code>singleton()</code>
</div>

<pre>
# livemodel.py - Singleton Pattern (lignes 318-337)
class LiveModel(Observable):
    __instance = None  # Attribut de classe

    @classmethod
    def singleton(cls, width=40, height=40):
        if cls.__instance is None:
            cls.__instance = cls(width, height)
        return cls.__instance
</pre>

<!-- ========================================== -->
<h2>8. Design Pattern : Iterator</h2>
<!-- ========================================== -->

<div class="pattern">
    <h3>Explication technique</h3>
    <p>Le pattern Iterator fournit un moyen de parcourir une collection sans exposer sa structure interne. En Python, il est implemente via un generateur (<code>yield</code>) qui produit les elements un par un de maniere lazy (a la demande).</p>
</div>

<div class="localisation">
    <strong>Localisation dans le code :</strong><br>
    - <code>liveview.py:249-264</code> : Methode <code>__grid_iterator()</code><br>
    - <code>liveview.py:192</code> : Utilisation dans <code>display_grid()</code>
</div>

<pre>
# liveview.py - Iterator Pattern (lignes 249-264)
def __grid_iterator(self, grid):
    """Generateur qui parcourt la grille cellule par cellule"""
    for row in range(len(grid)):
        for col in range(len(grid[row])):
            yield (row, col, grid[row][col])

# Utilisation (ligne 192)
for row, col, cell in self.__grid_iterator(grid):
    self.draw_cell(row, col, cell)
</pre>

<!-- ========================================== -->
<h2>9. Methodes Magiques</h2>
<!-- ========================================== -->

<div class="concept">
    <h3>Explication technique</h3>
    <p>Les methodes magiques (ou dunder methods) sont des methodes speciales Python encadrees par <code>__</code>. Elles permettent de personnaliser le comportement des objets avec les operateurs et fonctions natives (<code>str()</code>, <code>len()</code>, etc.).</p>
</div>

<div class="localisation">
    <strong>Localisation dans le code :</strong><br>
    - <code>livemodel.py:190-204</code> : <code>__init__()</code> de LiveCell<br>
    - <code>livemodel.py:206-208</code> : <code>__str__()</code> de LiveCell<br>
    - <code>livemodel.py:339-352</code> : <code>__init__()</code> de LiveModel<br>
    - <code>livemodel.py:354-361</code> : <code>__str__()</code> de LiveModel<br>
    - <code>livecounter.py:59-70</code> : <code>__str__()</code> de LiveCounter
</div>

<pre>
# livemodel.py - Methode magique __str__ (lignes 206-208)
def __str__(self):
    return "1" if self.__state else "0"

# livemodel.py - __str__ de LiveModel (lignes 354-361)
def __str__(self):
    result = f"Generation {self.__generation}\n"
    for row in range(self.__height):
        for col in range(self.__width):
            result += str(self.__grid[row][col])
        result += "\n"
    return result
</pre>

<!-- ========================================== -->
<h2>10. Decorateurs @property</h2>
<!-- ========================================== -->

<div class="concept">
    <h3>Explication technique</h3>
    <p>Le decorateur <code>@property</code> transforme une methode en attribut en lecture seule. Combine avec <code>@attr.setter</code>, il permet de controler l'acces aux attributs prives tout en gardant une syntaxe simple d'utilisation.</p>
</div>

<div class="localisation">
    <strong>Localisation dans le code :</strong><br>
    - <code>livemodel.py:210-298</code> : Properties de LiveCell<br>
    - <code>livemodel.py:363-381</code> : Properties de LiveModel<br>
    - <code>liveview.py:67-75</code> : Properties de LiveCanvas<br>
    - <code>livecounter.py:34-57</code> : Properties de LiveCounter
</div>

<pre>
# livemodel.py - Decorateur @property (lignes 210-218)
@property
def state(self):
    """Getter - lecture de l'attribut"""
    return self.__state

@state.setter
def state(self, value):
    """Setter - modification controlee"""
    self.__state = value

# Utilisation comme un attribut simple
cell.state = True    # Appelle le setter
print(cell.state)    # Appelle le getter
</pre>

<!-- ========================================== -->
<h2>11. Separation des Indices (Model) et Pixels (View)</h2>
<!-- ========================================== -->

<div class="concept">
    <h3>Explication technique</h3>
    <p>Le Model utilise des indices logiques (0, 1, 2...) pour representer la grille, tandis que la View utilise des coordonnees en pixels (0, 10, 20...) pour l'affichage. Cette separation permet de modifier la taille d'affichage sans toucher a la logique metier.</p>
</div>

<div class="localisation">
    <strong>Localisation dans le code :</strong><br>
    - <code>livemodel.py:659-669</code> : Indices standards dans <code>__create_grid()</code><br>
    - <code>liveview.py:211-229</code> : Conversion indices vers pixels <code>__model_to_canvas()</code><br>
    - <code>liveview.py:231-247</code> : Conversion pixels vers indices <code>__canvas_to_model()</code>
</div>

<pre>
# liveview.py - Conversion Model -> View (lignes 211-229)
def __model_to_canvas(self, row, col):
    """Convertit indices (0,1,2) en pixels (0,10,20)"""
    x1 = col * self.__cell_size  # ex: 2 * 10 = 20
    y1 = row * self.__cell_size
    x2 = x1 + self.__cell_size
    y2 = y1 + self.__cell_size
    return (x1, y1, x2, y2)

# liveview.py - Conversion View -> Model (lignes 231-247)
def __canvas_to_model(self, x, y):
    """Convertit pixels en indices"""
    col = x // self.__cell_size  # ex: 25 // 10 = 2
    row = y // self.__cell_size
    return (row, col)
</pre>

<!-- ========================================== -->
<h2>12. Affichage des Couleurs selon l'Etat des Cellules</h2>
<!-- ========================================== -->

<div class="concept">
    <h3>Explication technique</h3>
    <p>Les cellules sont affichees avec des couleurs differentes selon leur etat et leur evolution : gris (initial), vert (nouvellement nee), bleu (stable >= 2 generations), rouge (va mourir), jaune (nee et va mourir).</p>
</div>

<div class="localisation">
    <strong>Localisation dans le code :</strong><br>
    - <code>liveview.py:56-65</code> : Dictionnaire des couleurs<br>
    - <code>liveview.py:138-167</code> : Logique de couleur dans <code>draw_cell()</code><br>
    - <code>livemodel.py:519-555</code> : Calcul des flags dans <code>evolve()</code>
</div>

<pre>
# liveview.py - Dictionnaire des couleurs (lignes 56-65)
self.__colors = {
    'color_dead': 'white',
    'color_initial': '#888888',      # Gris
    'color_newly_born': '#44DD44',   # Vert
    'color_long_lived': '#4444FF',   # Bleu
    'color_will_die': '#FF4444',     # Rouge
    'color_born_and_die': '#FFDD44', # Jaune
}

# liveview.py - Selection de la couleur (lignes 151-161)
if cell_obj.is_newly_born and cell_obj.will_die_next_gen:
    fill_color = self.__colors['color_born_and_die']  # Jaune
elif cell_obj.is_newly_born:
    fill_color = self.__colors['color_newly_born']    # Vert
elif cell_obj.will_die_next_gen:
    fill_color = self.__colors['color_will_die']      # Rouge
elif cell_obj.is_long_lived:
    fill_color = self.__colors['color_long_lived']    # Bleu
</pre>

<!-- ========================================== -->
<h2>13. Tests Unitaires</h2>
<!-- ========================================== -->

<div class="concept">
    <h3>Explication technique</h3>
    <p>Chaque module contient un bloc <code>if __name__ == "__main__"</code> qui execute des tests lorsque le fichier est lance directement. Cela permet de verifier le bon fonctionnement de chaque classe independamment.</p>
</div>

<div class="localisation">
    <strong>Localisation dans le code :</strong><br>
    - <code>livemodel.py:715-741</code> : Tests de LiveModel<br>
    - <code>liveview.py:445-472</code> : Tests de LiveView<br>
    - <code>livecontroller.py:261-284</code> : Tests de LiveController<br>
    - <code>livecounter.py:156-174</code> : Tests de LiveCounter
</div>

<pre>
# livemodel.py - Tests unitaires (lignes 715-741)
if __name__ == "__main__":
    print("Testing LiveModel...")
    model = LiveModel(width=10, height=10)
    model.toggle_cell(5, 5)
    model.evolve()
    model.set_random_configuration(0.25)
    model.set_cannon_configuration()
    print("LiveModel tests completed!")
</pre>

<!-- ========================================== -->
<h2>Tableau Recapitulatif</h2>
<!-- ========================================== -->

<table>
    <tr>
        <th>Concept</th>
        <th>Fichier</th>
        <th>Lignes</th>
    </tr>
    <tr>
        <td>Architecture MVC</td>
        <td>main.py</td>
        <td>34-44</td>
    </tr>
    <tr>
        <td>Encapsulation (attributs prives)</td>
        <td>livemodel.py</td>
        <td>197-204, 347-352</td>
    </tr>
    <tr>
        <td>Composition</td>
        <td>livemodel.py</td>
        <td>659-669</td>
    </tr>
    <tr>
        <td>Heritage / Classes abstraites</td>
        <td>livemodel.py</td>
        <td>21-98, 301</td>
    </tr>
    <tr>
        <td>Observer Pattern</td>
        <td>livemodel.py, livecontroller.py</td>
        <td>387-414, 63-74</td>
    </tr>
    <tr>
        <td>Strategy Pattern</td>
        <td>livemodel.py</td>
        <td>83-175, 563-579</td>
    </tr>
    <tr>
        <td>Singleton Pattern</td>
        <td>livemodel.py</td>
        <td>318-337</td>
    </tr>
    <tr>
        <td>Iterator Pattern</td>
        <td>liveview.py</td>
        <td>249-264</td>
    </tr>
    <tr>
        <td>Methodes magiques</td>
        <td>livemodel.py</td>
        <td>206-208, 354-361</td>
    </tr>
    <tr>
        <td>Decorateurs @property</td>
        <td>livemodel.py</td>
        <td>210-298, 363-381</td>
    </tr>
    <tr>
        <td>Separation indices/pixels</td>
        <td>liveview.py</td>
        <td>211-247</td>
    </tr>
    <tr>
        <td>Couleurs selon etat</td>
        <td>liveview.py, livemodel.py</td>
        <td>56-65, 138-167, 519-555</td>
    </tr>
    <tr>
        <td>Tests unitaires</td>
        <td>Tous les fichiers</td>
        <td>Sections __main__</td>
    </tr>
</table>

</body>
</html>
