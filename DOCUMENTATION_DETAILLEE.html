<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <title>Game of Life - Documentation DÃ©taillÃ©e du Code</title>
    <style>
        body {
            font-family: 'Times New Roman', serif;
            line-height: 1.8;
            max-width: 210mm;
            margin: 0 auto;
            padding: 20mm;
            color: #000;
            background: white;
        }
        h1 {
            color: #0066cc;
            border-bottom: 3px solid #0066cc;
            padding-bottom: 10px;
            page-break-before: always;
            font-size: 24pt;
        }
        h1:first-of-type {
            page-break-before: auto;
        }
        h2 {
            color: #0066cc;
            border-bottom: 2px solid #0066cc;
            padding-bottom: 5px;
            margin-top: 30px;
            font-size: 18pt;
        }
        h3 {
            color: #0088cc;
            margin-top: 20px;
            font-size: 14pt;
        }
        h4 {
            color: #00aacc;
            margin-top: 15px;
            font-size: 12pt;
        }
        p {
            text-align: justify;
            margin: 10px 0;
        }
        code {
            background: #f4f4f4;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
        }
        pre {
            background: #f8f8f8;
            border: 1px solid #ddd;
            border-left: 4px solid #0066cc;
            padding: 15px;
            overflow-x: auto;
            line-height: 1.4;
            font-family: 'Courier New', monospace;
            font-size: 0.85em;
            page-break-inside: avoid;
            margin: 15px 0;
        }
        .explication {
            background: #e7f3ff;
            border-left: 4px solid #0066cc;
            padding: 15px;
            margin: 15px 0;
            page-break-inside: avoid;
        }
        .concept {
            background: #f0f8ff;
            border: 2px solid #4a90e2;
            padding: 20px;
            margin: 20px 0;
            border-radius: 5px;
            page-break-inside: avoid;
        }
        .important {
            background: #fff3cd;
            border-left: 4px solid #ff9800;
            padding: 15px;
            margin: 15px 0;
            page-break-inside: avoid;
        }
        .pattern {
            background: #d4edda;
            border-left: 4px solid #28a745;
            padding: 15px;
            margin: 15px 0;
            page-break-inside: avoid;
        }
        .exemple {
            background: #f9f9f9;
            border: 1px dashed #666;
            padding: 15px;
            margin: 15px 0;
            page-break-inside: avoid;
        }
        .pourquoi {
            background: #fff0f5;
            border-left: 4px solid #e91e63;
            padding: 15px;
            margin: 15px 0;
            page-break-inside: avoid;
        }
        table {
            border-collapse: collapse;
            width: 100%;
            margin: 20px 0;
            page-break-inside: avoid;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 12px;
            text-align: left;
        }
        th {
            background-color: #0066cc;
            color: white;
            font-weight: bold;
        }
        tr:nth-child(even) {
            background-color: #f9f9f9;
        }
        .toc {
            background: #f4f4f4;
            padding: 20px;
            margin: 20px 0;
            border: 1px solid #ddd;
        }
        .toc ul {
            list-style: none;
            padding-left: 0;
        }
        .toc li {
            margin: 8px 0;
        }
        .toc a {
            color: #0066cc;
            text-decoration: none;
        }
        .toc a:hover {
            text-decoration: underline;
        }
        ul, ol {
            margin: 10px 0;
            padding-left: 30px;
        }
        li {
            margin: 5px 0;
        }
        .diagram {
            background: white;
            border: 2px solid #0066cc;
            padding: 20px;
            margin: 20px 0;
            text-align: center;
            font-family: monospace;
            page-break-inside: avoid;
        }
        @media print {
            body {
                max-width: 100%;
                padding: 0;
            }
            h1 {
                page-break-before: always;
            }
            h1:first-of-type {
                page-break-before: auto;
            }
            .explication, .important, .pattern, pre, table, .concept, .diagram {
                page-break-inside: avoid;
            }
        }
    </style>
</head>
<body>

<h1>Documentation DÃ©taillÃ©e et PÃ©dagogique</h1>
<h2>Game of Life - Projet Q54 - Programmation OrientÃ©e Objet</h2>

<div class="important">
<strong>âš ï¸ Ã€ Propos de ce Document</strong><br><br>
Ce document est une documentation <strong>exhaustive et pÃ©dagogique</strong> du projet Game of Life. Il ne se contente pas de montrer le code, mais <strong>explique en dÃ©tail</strong> :
<ul>
<li><strong>Pourquoi</strong> chaque dÃ©cision de conception a Ã©tÃ© prise</li>
<li><strong>Comment</strong> chaque pattern et principe POO est appliquÃ©</li>
<li><strong>Quand</strong> et <strong>oÃ¹</strong> utiliser chaque composant</li>
<li>Les <strong>avantages</strong> de l'approche orientÃ©e objet par rapport au code procÃ©dural</li>
<li>Les <strong>principes thÃ©oriques</strong> derriÃ¨re chaque implÃ©mentation</li>
</ul>
Ce document est conÃ§u pour dÃ©montrer une comprÃ©hension approfondie des concepts POO au professeur.
</div>

<div class="toc">
<h3>Table des MatiÃ¨res</h3>
<ul>
    <li><a href="#intro">1. Introduction - Concepts Fondamentaux</a>
        <ul>
            <li>Vue d'ensemble du projet</li>
            <li>Architecture MVC expliquÃ©e en dÃ©tail</li>
            <li>Principes POO de base</li>
        </ul>
    </li>
    <li><a href="#mvc-detail">2. Architecture MVC - Explication Approfondie</a></li>
    <li><a href="#livemodel">3. livemodel.py - Le ModÃ¨le (CÅ“ur de la Logique)</a></li>
    <li><a href="#liveview">4. liveview.py - La Vue (Interface Graphique)</a></li>
    <li><a href="#livecontroller">5. livecontroller.py - Le ContrÃ´leur (Chef d'Orchestre)</a></li>
    <li><a href="#livecounter">6. livecounter.py - Statistiques (Module Optionnel)</a></li>
    <li><a href="#main">7. main.py - Point d'EntrÃ©e (Bootstrap)</a></li>
    <li><a href="#patterns">8. Design Patterns - ThÃ©orie et Pratique</a></li>
    <li><a href="#poo">9. Principes POO - Application ConcrÃ¨te</a></li>
    <li><a href="#comparison">10. Comparaison Code ProcÃ©dural vs OrientÃ© Objet</a></li>
</ul>
</div>

<h1 id="intro">1. Introduction - Concepts Fondamentaux</h1>

<h2>1.1 Vue d'Ensemble du Projet</h2>

<div class="concept">
<h3>ğŸ¯ Objectif PÃ©dagogique</h3>
<p>
Ce projet dÃ©montre la <strong>conversion d'une application procÃ©durale</strong> (style "programmation structurÃ©e") vers une <strong>application orientÃ©e objet moderne</strong> suivant les meilleures pratiques de l'industrie.
</p>
<p>
Le Jeu de la Vie de Conway a Ã©tÃ© choisi car il prÃ©sente plusieurs dÃ©fis intÃ©ressants :
</p>
<ul>
<li><strong>Ã‰tat complexe</strong> : Une grille de cellules avec leurs Ã©tats et voisins</li>
<li><strong>Logique mÃ©tier claire</strong> : Les rÃ¨gles de Conway sont bien dÃ©finies</li>
<li><strong>Interface graphique</strong> : NÃ©cessite une sÃ©paration claire entre logique et affichage</li>
<li><strong>Animation</strong> : Gestion du temps et des Ã©vÃ©nements</li>
<li><strong>Statistiques</strong> : Calculs sÃ©parÃ©s de la logique principale</li>
</ul>
</div>

<h2>1.2 Qu'est-ce que le Jeu de la Vie ?</h2>

<div class="explication">
<h3>ğŸ“š Contexte Historique</h3>
<p>
Le <strong>Jeu de la Vie</strong> (Game of Life) a Ã©tÃ© inventÃ© en 1970 par le mathÃ©maticien britannique <strong>John Horton Conway</strong>. Ce n'est pas vraiment un "jeu" au sens classique (pas de joueurs, pas de score Ã  battre), mais un <strong>automate cellulaire</strong> - un modÃ¨le mathÃ©matique fascinant.
</p>

<h4>Les RÃ¨gles Simples</h4>
<p>Le jeu se joue sur une grille bidimensionnelle infinie de cellules carrÃ©es. Chaque cellule peut Ãªtre dans deux Ã©tats :</p>
<ul>
<li><strong>Vivante</strong> (alive) - reprÃ©sentÃ©e en noir dans notre implÃ©mentation</li>
<li><strong>Morte</strong> (dead) - reprÃ©sentÃ©e en blanc</li>
</ul>

<p>Ã€ chaque "gÃ©nÃ©ration" (tick), l'Ã©tat de chaque cellule Ã©volue selon <strong>trois rÃ¨gles simples</strong> :</p>

<ol>
<li><strong>Survie</strong> : Une cellule <em>vivante</em> avec 2 ou 3 voisins vivants â†’ reste vivante</li>
<li><strong>Naissance</strong> : Une cellule <em>morte</em> avec exactement 3 voisins vivants â†’ devient vivante</li>
<li><strong>Mort</strong> : Dans tous les autres cas â†’ la cellule meurt ou reste morte
    <ul>
        <li>Moins de 2 voisins â†’ mort par <em>sous-population</em></li>
        <li>Plus de 3 voisins â†’ mort par <em>surpopulation</em></li>
    </ul>
</li>
</ol>

<h4>Pourquoi c'est Fascinant ?</h4>
<p>
MalgrÃ© ces rÃ¨gles ultra-simples, le Jeu de la Vie produit des comportements <strong>extrÃªmement complexes</strong> :
</p>
<ul>
<li><strong>Still lifes</strong> : Structures stables qui ne changent jamais (blocs, ruches, bateaux)</li>
<li><strong>Oscillateurs</strong> : Structures qui reviennent pÃ©riodiquement au mÃªme Ã©tat (clignotants, pulsars)</li>
<li><strong>Gliders</strong> : Structures qui se dÃ©placent diagonalement</li>
<li><strong>Canons</strong> : Structures qui gÃ©nÃ¨rent pÃ©riodiquement d'autres structures (comme le Gosper Glider Gun)</li>
</ul>

<p>
Le Jeu de la Vie est <strong>Turing-complet</strong>, ce qui signifie qu'on peut thÃ©oriquement construire un ordinateur complet Ã  l'intÃ©rieur ! C'est un exemple parfait de la <strong>complexitÃ© Ã©mergente</strong> : des rÃ¨gles simples produisent des comportements complexes.
</p>
</div>

<h2>1.3 Architecture GÃ©nÃ©rale - Vision Ã  10,000 Pieds</h2>

<div class="concept">
<h3>ğŸ—ï¸ Les Trois Piliers de l'Application</h3>

<div class="diagram">
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                                                 â”‚
â”‚              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                   â”‚
â”‚              â”‚              â”‚                   â”‚
â”‚              â”‚     VIEW     â”‚â—„â”€â”€â”€â”€â”€â”€â”€â”€â”         â”‚
â”‚              â”‚  (liveview)  â”‚         â”‚         â”‚
â”‚              â”‚              â”‚         â”‚         â”‚
â”‚              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â”‚         â”‚
â”‚                     â–²                 â”‚         â”‚
â”‚                     â”‚                 â”‚         â”‚
â”‚                     â”‚ affiche         â”‚         â”‚
â”‚                     â”‚                 â”‚         â”‚
â”‚              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”‚         â”‚
â”‚              â”‚              â”‚         â”‚         â”‚
â”‚              â”‚  CONTROLLER  â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤         â”‚
â”‚              â”‚(livecontrol) â”‚  coordonne        â”‚
â”‚              â”‚              â”‚         â”‚         â”‚
â”‚              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â”‚         â”‚
â”‚                     â”‚                 â”‚         â”‚
â”‚                     â”‚ modifie         â”‚         â”‚
â”‚                     â”‚                 â”‚         â”‚
â”‚                     â–¼                 â”‚         â”‚
â”‚              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”‚         â”‚
â”‚              â”‚              â”‚         â”‚         â”‚
â”‚              â”‚    MODEL     â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â”‚
â”‚              â”‚  (livemodel) â”‚  notifie          â”‚
â”‚              â”‚              â”‚  (Observer)       â”‚
â”‚              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                   â”‚
â”‚                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
</div>

<p><strong>Flux de donnÃ©es et responsabilitÃ©s :</strong></p>

<table>
<tr>
    <th>Composant</th>
    <th>RÃ´le</th>
    <th>Ce qu'il FAIT</th>
    <th>Ce qu'il NE FAIT PAS</th>
</tr>
<tr>
    <td><strong>MODEL</strong><br>(livemodel.py)</td>
    <td>Le Cerveau</td>
    <td>
        â€¢ Stocke l'Ã©tat du jeu<br>
        â€¢ Applique les rÃ¨gles de Conway<br>
        â€¢ Calcule les gÃ©nÃ©rations<br>
        â€¢ GÃ¨re les configurations
    </td>
    <td>
        â€¢ ConnaÃ®tre l'interface graphique<br>
        â€¢ Savoir comment afficher les cellules<br>
        â€¢ GÃ©rer les Ã©vÃ©nements utilisateur
    </td>
</tr>
<tr>
    <td><strong>VIEW</strong><br>(liveview.py)</td>
    <td>Les Yeux et les Mains</td>
    <td>
        â€¢ Affiche la grille Ã  l'Ã©cran<br>
        â€¢ Dessine les cellules et la grille<br>
        â€¢ CrÃ©e les boutons et contrÃ´les<br>
        â€¢ Convertit pixels â†” indices
    </td>
    <td>
        â€¢ ConnaÃ®tre les rÃ¨gles du jeu<br>
        â€¢ DÃ©cider quelles cellules sont vivantes<br>
        â€¢ Calculer les gÃ©nÃ©rations
    </td>
</tr>
<tr>
    <td><strong>CONTROLLER</strong><br>(livecontroller.py)</td>
    <td>Le Chef d'Orchestre</td>
    <td>
        â€¢ Coordonne Model et View<br>
        â€¢ GÃ¨re les Ã©vÃ©nements (clics, boutons)<br>
        â€¢ Met Ã  jour l'affichage<br>
        â€¢ GÃ¨re l'animation
    </td>
    <td>
        â€¢ Contenir de la logique mÃ©tier<br>
        â€¢ Dessiner directement<br>
        â€¢ Calculer les rÃ¨gles du jeu
    </td>
</tr>
</table>
</div>

<h1 id="mvc-detail">2. Architecture MVC - Explication Approfondie</h1>

<h2>2.1 Qu'est-ce que MVC ?</h2>

<div class="concept">
<h3>ğŸ“– DÃ©finition et Histoire</h3>

<p>
<strong>MVC</strong> signifie <strong>Model-View-Controller</strong> (ModÃ¨le-Vue-ContrÃ´leur en franÃ§ais). C'est un <strong>pattern architectural</strong> (pas juste un design pattern) inventÃ© dans les annÃ©es 1970 chez Xerox PARC par Trygve Reenskaug pour le langage Smalltalk.
</p>

<h4>Le ProblÃ¨me que MVC RÃ©sout</h4>

<p>
Avant MVC, les applications mÃ©langeaient tout dans un seul endroit :
</p>

<pre>
<strong>âŒ Code "Spaghetti" Classique :</strong>

def main():
    # Logique mÃ©tier mÃ©langÃ©e avec l'affichage
    canvas = create_window()
    cells = [[False] * 40 for _ in range(40)]

    # Calcul mÃ©langÃ© avec le dessin
    for row in range(40):
        for col in range(40):
            if cells[row][col]:
                canvas.draw_rectangle(col*10, row*10, ...)  # Dessin
            neighbors = count_neighbors(cells, row, col)    # Logique
            if neighbors == 3:                              # RÃ¨gle
                cells[row][col] = True                      # Ã‰tat
</pre>

<p><strong>ProblÃ¨mes de cette approche :</strong></p>
<ul>
<li>âŒ <strong>ImpossibilitÃ© de tester</strong> la logique sans l'interface</li>
<li>âŒ <strong>Impossible de changer</strong> l'interface sans toucher Ã  la logique</li>
<li>âŒ <strong>Code difficile Ã  comprendre</strong> : tout est mÃ©langÃ©</li>
<li>âŒ <strong>RÃ©utilisation impossible</strong> : le code est monolithique</li>
<li>âŒ <strong>Travail en Ã©quipe difficile</strong> : conflit sur le mÃªme fichier</li>
</ul>

<h4>La Solution MVC</h4>

<p>
MVC <strong>sÃ©pare les responsabilitÃ©s</strong> en trois composants indÃ©pendants qui communiquent via des interfaces bien dÃ©finies :
</p>

<pre>
<strong>âœ… Architecture MVC Propre :</strong>

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  MODEL (Logique MÃ©tier)                         â”‚
â”‚  â€¢ Ã‰tat du jeu : grille de cellules             â”‚
â”‚  â€¢ RÃ¨gles de Conway                             â”‚
â”‚  â€¢ Calcul des gÃ©nÃ©rations                       â”‚
â”‚  â€¢ IndÃ©pendant de l'interface !                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚
         â”‚ notifie (Observer Pattern)
         â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  CONTROLLER (Coordination)                      â”‚
â”‚  â€¢ ReÃ§oit les Ã©vÃ©nements utilisateur            â”‚
â”‚  â€¢ Demande au Model de modifier l'Ã©tat          â”‚
â”‚  â€¢ Demande Ã  la View de se mettre Ã  jour        â”‚
â”‚  â€¢ GÃ¨re l'animation                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚
         â”‚ met Ã  jour
         â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  VIEW (Interface Graphique)                     â”‚
â”‚  â€¢ Affiche la grille                            â”‚
â”‚  â€¢ Dessine les cellules                         â”‚
â”‚  â€¢ CrÃ©e les boutons                             â”‚
â”‚  â€¢ GÃ¨re les pixels                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
</pre>
</div>

<h2>2.2 Les Avantages de MVC dans Notre Projet</h2>

<div class="explication">
<h3>ğŸ’¡ BÃ©nÃ©fices Concrets</h3>

<h4>1. TestabilitÃ©</h4>
<p>
Le Model peut Ãªtre testÃ© <strong>complÃ¨tement indÃ©pendamment</strong> de l'interface graphique :
</p>
<pre>
# Test du Model sans GUI
model = LiveModel(width=10, height=10)
model.toggle_cell(5, 5)
model.toggle_cell(5, 6)
model.toggle_cell(5, 7)
model.evolve()
assert model.grid[4][6].state == True  # Blinker pattern
</pre>

<h4>2. MaintenabilitÃ©</h4>
<p>
On peut modifier l'interface graphique sans toucher Ã  la logique mÃ©tier :
</p>
<ul>
<li>Changer Tkinter â†’ PyQt : <strong>seulement liveview.py change</strong></li>
<li>Ajouter une rÃ¨gle de jeu : <strong>seulement livemodel.py change</strong></li>
<li>Changer les contrÃ´les : <strong>seulement livecontroller.py change</strong></li>
</ul>

<h4>3. RÃ©utilisabilitÃ©</h4>
<p>
Le mÃªme Model peut Ãªtre utilisÃ© avec diffÃ©rentes Views :
</p>
<ul>
<li>View graphique (Tkinter) - <strong>actuelle</strong></li>
<li>View web (HTML/JavaScript) - <strong>possible</strong></li>
<li>View console (texte) - <strong>possible</strong></li>
<li>View pour tests automatisÃ©s - <strong>possible</strong></li>
</ul>

<h4>4. Travail en Ã‰quipe</h4>
<p>
Trois dÃ©veloppeurs peuvent travailler en parallÃ¨le sans conflit :
</p>
<ul>
<li><strong>Dev A</strong> : Travaille sur le Model (rÃ¨gles du jeu)</li>
<li><strong>Dev B</strong> : Travaille sur la View (interface)</li>
<li><strong>Dev C</strong> : Travaille sur le Controller (coordination)</li>
</ul>

<p>
Tant que les <strong>interfaces</strong> (mÃ©thodes publiques) restent stables, chacun peut travailler indÃ©pendamment.
</p>
</div>

<h2>2.3 SÃ©paration Cruciale : Indices vs Pixels</h2>

<div class="important">
<h3>âš ï¸ ProblÃ¨me Majeur du Code ProcÃ©dural</h3>

<p>
Le code procÃ©dural original mÃ©langeait deux types de coordonnÃ©es :
</p>

<h4>âŒ Code ProcÃ©dural (ProblÃ©matique)</h4>
<pre>
# Variables globales mÃ©langÃ©es
c = 10  # Taille de cellule en PIXELS
grille = []  # Grille en INDICES

# Calcul mÃ©langÃ© pixels/indices
for i in range(0, width, c):      # â† i en PIXELS (0, 10, 20...)
    for j in range(0, height, c):  # â† j en PIXELS
        if grille[j//c][i//c]:     # â† Division pour revenir aux indices !
            canvas.create_rectangle(i, j, i+c, j+c)  # Pixels
</pre>

<p><strong>ProblÃ¨mes de cette approche :</strong></p>
<ul>
<li>ğŸ”´ Boucles en pixels (<code>range(0, width, c)</code>) alors qu'on travaille sur des indices</li>
<li>ğŸ”´ Divisions constantes (<code>i//c</code>, <code>j//c</code>) pour convertir</li>
<li>ğŸ”´ Confusion entre coordonnÃ©es pixels et indices de grille</li>
<li>ğŸ”´ Changement de taille de cellule nÃ©cessite de tout modifier</li>
<li>ğŸ”´ Code difficile Ã  comprendre et Ã  maintenir</li>
</ul>

<h4>âœ… Notre Solution MVC (Claire)</h4>

<p><strong>Principe :</strong> SÃ©paration stricte des systÃ¨mes de coordonnÃ©es</p>

<table>
<tr>
    <th>Composant</th>
    <th>SystÃ¨me de CoordonnÃ©es</th>
    <th>Exemple</th>
</tr>
<tr>
    <td><strong>MODEL</strong></td>
    <td>Indices standards (0, 1, 2, 3...)</td>
    <td><code>grid[5][10]</code> = cellule ligne 5, colonne 10</td>
</tr>
<tr>
    <td><strong>VIEW</strong></td>
    <td>Pixels (0, 10, 20, 30...)</td>
    <td><code>rectangle(50, 100, 60, 110)</code> = 50px, 100px</td>
</tr>
<tr>
    <td><strong>CONVERSION</strong></td>
    <td>EffectuÃ©e UNIQUEMENT dans la View</td>
    <td><code>x = col * cell_size</code></td>
</tr>
</table>

<pre>
<strong>Exemple Concret de SÃ©paration :</strong>

# Dans le MODEL - Indices standards
for row in range(self.__height):      # row = 0, 1, 2, 3...
    for col in range(self.__width):    # col = 0, 1, 2, 3...
        neighbors = self.__count_neighbors(row, col)
        # Travaille UNIQUEMENT avec des indices

# Dans la VIEW - Conversion vers pixels
def __model_to_canvas(self, row, col):
    x1 = col * self.__cell_size  # 0â†’0, 1â†’10, 2â†’20...
    y1 = row * self.__cell_size
    return (x1, y1, x2, y2)  # CoordonnÃ©es en PIXELS pour Tkinter
</pre>

<p><strong>Avantages de cette sÃ©paration :</strong></p>
<ul>
<li>âœ… Le Model ne connaÃ®t pas les pixels â†’ peut Ãªtre rÃ©utilisÃ© avec n'importe quelle taille</li>
<li>âœ… Pas de divisions dans le Model â†’ plus rapide et plus clair</li>
<li>âœ… Changement de taille de cellule â†’ modification dans la View seulement</li>
<li>âœ… Code beaucoup plus lisible et maintenable</li>
</ul>
</div>

<h1 id="livemodel">3. livemodel.py - Le ModÃ¨le (CÅ“ur de la Logique)</h1>

<h2>3.1 Vue d'Ensemble du ModÃ¨le</h2>

<div class="concept">
<h3>ğŸ§  Le ModÃ¨le : Le Cerveau de l'Application</h3>

<p>
Le <strong>ModÃ¨le</strong> est le composant le plus important de l'application. Il contient toute la <strong>logique mÃ©tier</strong> - c'est-Ã -dire toutes les rÃ¨gles et tous les calculs qui font fonctionner le jeu.
</p>

<p><strong>ResponsabilitÃ©s du ModÃ¨le :</strong></p>
<ol>
<li><strong>Stocker l'Ã©tat</strong> : La grille de cellules, la gÃ©nÃ©ration actuelle</li>
<li><strong>Appliquer les rÃ¨gles</strong> : Les trois rÃ¨gles de Conway</li>
<li><strong>Calculer les Ã©volutions</strong> : Passer d'une gÃ©nÃ©ration Ã  la suivante</li>
<li><strong>Notifier les changements</strong> : Informer le Controller via le Pattern Observer</li>
<li><strong>GÃ©rer les configurations</strong> : Random, Cannon, etc. via le Pattern Strategy</li>
</ol>

<p><strong>Ce que le ModÃ¨le NE FAIT PAS :</strong></p>
<ul>
<li>âŒ Ne connaÃ®t rien de Tkinter ou de l'affichage</li>
<li>âŒ Ne sait pas qu'il y a des pixels</li>
<li>âŒ Ne gÃ¨re pas les Ã©vÃ©nements utilisateur</li>
<li>âŒ Ne dÃ©cide pas quand mettre Ã  jour l'affichage</li>
</ul>

<p>
Cette sÃ©paration stricte permet de <strong>tester le ModÃ¨le indÃ©pendamment</strong> et de le <strong>rÃ©utiliser</strong> avec diffÃ©rentes interfaces.
</p>
</div>

<h2>3.2 Classes Abstraites - Les Interfaces</h2>

<div class="concept">
<h3>ğŸ“ Les Abstract Base Classes (ABC) en Python</h3>

<p>
En Python, les <strong>Abstract Base Classes</strong> (classes abstraites) permettent de dÃ©finir des <strong>interfaces</strong> - c'est-Ã -dire des "contrats" que les classes concrÃ¨tes doivent respecter.
</p>

<h4>Pourquoi Utiliser des Classes Abstraites ?</h4>

<ol>
<li><strong>DÃ©finir un Contrat</strong> : "Toute classe qui hÃ©rite de moi doit implÃ©menter ces mÃ©thodes"</li>
<li><strong>Documentation Implicite</strong> : On voit immÃ©diatement quelles mÃ©thodes sont nÃ©cessaires</li>
<li><strong>VÃ©rification au Runtime</strong> : Python empÃªche l'instanciation si les mÃ©thodes ne sont pas implÃ©mentÃ©es</li>
<li><strong>Polymorphisme</strong> : DiffÃ©rentes classes peuvent Ãªtre utilisÃ©es de maniÃ¨re interchangeable</li>
</ol>

<h4>Syntaxe Python pour les ABC</h4>
<pre>
from abc import ABC, abstractmethod

class MaClasseAbstraite(ABC):
    @abstractmethod
    def ma_methode(self):
        """Cette mÃ©thode DOIT Ãªtre implÃ©mentÃ©e par les sous-classes"""
        pass
</pre>

<p>
Si on essaie de crÃ©er une instance sans implÃ©menter <code>ma_methode</code>, Python lÃ¨ve une <code>TypeError</code>.
</p>
</div>

<h3>3.2.1 Pattern Observer - Les Interfaces</h3>

<div class="pattern">
<h3>ğŸ¯ Design Pattern : Observer (Observateur)</h3>

<p>
Le <strong>Pattern Observer</strong> (aussi appelÃ© <em>Publisher-Subscriber</em> ou <em>Pub-Sub</em>) est un des patterns les plus utilisÃ©s en programmation. Il rÃ©sout le problÃ¨me suivant :
</p>

<div class="pourquoi">
<h4>â“ ProblÃ¨me Ã  RÃ©soudre</h4>
<p>
Comment faire pour qu'un objet (le Model) puisse <strong>notifier automatiquement</strong> d'autres objets (le Controller) quand son Ã©tat change, <strong>sans connaÃ®tre ces objets directement</strong> ?
</p>

<p><strong>Exemple concret :</strong></p>
<ul>
<li>Le Model calcule une nouvelle gÃ©nÃ©ration</li>
<li>Il doit mettre Ã  jour l'affichage</li>
<li>Mais il ne doit PAS connaÃ®tre le Controller ou la View directement (couplage fort)</li>
</ul>

<p><strong>Solution : Le Pattern Observer</strong></p>
<ul>
<li>Le Model est un <strong>Observable</strong> (Subject) : il peut Ãªtre observÃ©</li>
<li>Le Controller est un <strong>Observer</strong> : il observe le Model</li>
<li>Le Model maintient une liste d'Observers et les notifie automatiquement</li>
<li>Le Model ne sait pas ce que fait l'Observer â†’ <strong>couplage lÃ¢che</strong></li>
</ul>
</div>
</div>

<h4>Interface Observer</h4>

<pre>
class Observer(ABC):
    """
    Interface abstraite pour les observateurs.

    <strong>RÃ´le :</strong>
    DÃ©finit le contrat que tout observateur doit respecter.
    Dans notre cas, le Controller implÃ©mente cette interface.

    <strong>MÃ©thode requise :</strong>
    update(subject) - AppelÃ©e quand l'objet observÃ© change
    """

    @abstractmethod
    def update(self, subject):
        """
        Notification de changement.

        Cette mÃ©thode est appelÃ©e automatiquement par l'objet observÃ©
        (le Model) quand son Ã©tat change.

        Args:
            subject: L'objet qui a changÃ© (gÃ©nÃ©ralement le Model)

        <strong>ResponsabilitÃ© de l'implÃ©mentation :</strong>
        L'observateur concret (Controller) dÃ©cide quoi faire quand
        il reÃ§oit cette notification. Dans notre cas : mettre Ã  jour
        l'affichage.
        """
        pass
</pre>

<div class="explication">
<h4>ğŸ’¡ Explication DÃ©taillÃ©e de l'Interface Observer</h4>

<p><strong>Pourquoi une mÃ©thode appelÃ©e "update" ?</strong></p>
<p>
C'est la convention du Pattern Observer. Le nom <code>update()</code> indique "mets-toi Ã  jour avec les nouvelles donnÃ©es". D'autres noms possibles seraient <code>notify()</code> ou <code>on_change()</code>, mais <code>update()</code> est le standard.
</p>

<p><strong>Pourquoi passer "subject" en paramÃ¨tre ?</strong></p>
<p>
L'observateur a besoin de savoir <strong>qui</strong> a changÃ© pour pouvoir rÃ©cupÃ©rer les nouvelles donnÃ©es. Si on observe plusieurs Models, on doit savoir lequel a changÃ©.
</p>

<pre>
<strong>Exemple d'utilisation :</strong>

class MonController(Observer):
    def update(self, subject):
        # subject = le Model qui a changÃ©
        nouvelle_grille = subject.grid
        generation = subject.generation
        # Maintenant je peux mettre Ã  jour l'affichage
</pre>

<p><strong>Pourquoi @abstractmethod ?</strong></p>
<p>
Le dÃ©corateur <code>@abstractmethod</code> force les sous-classes Ã  implÃ©menter cette mÃ©thode. Si on oublie, Python gÃ©nÃ¨re une erreur au moment de l'instanciation. C'est une sÃ©curitÃ© qui garantit que le contrat est respectÃ©.
</p>
</div>

<h4>Interface Observable</h4>

<pre>
class Observable(ABC):
    """
    Interface abstraite pour les objets observables (sujets).

    <strong>RÃ´le :</strong>
    DÃ©finit le contrat pour un objet qui peut Ãªtre observÃ©.
    Dans notre cas, le Model implÃ©mente cette interface.

    <strong>MÃ©thodes requises :</strong>
    - attach(observer) : Enregistrer un observateur
    - detach(observer) : DÃ©senregistrer un observateur
    - notify_observers() : Notifier tous les observateurs
    """

    @abstractmethod
    def attach(self, observer):
        """
        Enregistrer un observateur.

        Args:
            observer (Observer): L'observateur Ã  enregistrer

        <strong>Quand l'utiliser ?</strong>
        Au dÃ©marrage de l'application, le Controller s'enregistre
        pour recevoir les notifications du Model.
        """
        pass

    @abstractmethod
    def detach(self, observer):
        """
        DÃ©senregistrer un observateur.

        Args:
            observer (Observer): L'observateur Ã  retirer

        <strong>Pourquoi c'est important ?</strong>
        Pour Ã©viter les fuites mÃ©moire. Si on ne dÃ©senregistre pas
        les observateurs, ils restent en mÃ©moire mÃªme s'ils ne sont
        plus utilisÃ©s.
        """
        pass

    @abstractmethod
    def notify_observers(self):
        """
        Notifier tous les observateurs enregistrÃ©s.

        <strong>Quand l'appeler ?</strong>
        AprÃ¨s CHAQUE modification de l'Ã©tat interne.
        Dans notre cas : aprÃ¨s evolve(), toggle_cell(), clear_grid(), etc.

        <strong>Comment Ã§a marche ?</strong>
        Parcourt la liste d'observateurs et appelle update() sur chacun.
        """
        pass
</pre>

<div class="explication">
<h4>ğŸ’¡ Explication DÃ©taillÃ©e de l'Interface Observable</h4>

<p><strong>Pattern de conception :</strong></p>

<pre>
<strong>SÃ©quence typique d'utilisation :</strong>

1. INITIALISATION
   model = LiveModel()
   controller = LiveController(model, view)
   model.attach(controller)  # â† Le Controller s'enregistre

2. MODIFICATION DE L'Ã‰TAT
   model.toggle_cell(5, 5)
      â†“
   # Ã€ l'intÃ©rieur de toggle_cell() :
   self.__grid[5][5].state = not self.__grid[5][5].state
   self.notify_observers()  # â† Notification automatique
      â†“
   # notify_observers() parcourt la liste :
   for observer in self.__observers:
       observer.update(self)  # â† Appel Ã  controller.update()
      â†“
   # Dans controller.update() :
   self.__update_display()  # â† Mise Ã  jour de l'affichage
</pre>

<p><strong>Avantage : Couplage LÃ¢che</strong></p>
<p>
Le Model ne connaÃ®t pas le Controller. Il sait juste qu'il a des "observateurs" qui implÃ©mentent <code>update()</code>. C'est tout. Il ne sait pas ce qu'ils font dans <code>update()</code>. C'est le principe du <strong>couplage lÃ¢che</strong> : les composants communiquent via des interfaces, pas en se connaissant directement.
</p>

<p><strong>Analogie du monde rÃ©el :</strong></p>
<p>
Imaginez un journal (le Model). Des gens s'abonnent au journal (attach). Quand il y a une nouvelle Ã©dition (notify_observers), tous les abonnÃ©s reÃ§oivent le journal (update). Le journal ne sait pas ce que les abonnÃ©s font avec - certains le lisent, d'autres le recyclent, d'autres le gardent. Le journal s'en fiche, il notifie juste.
</p>
</div>

<h3>3.2.2 Pattern Strategy - L'Interface</h3>

<div class="pattern">
<h3>ğŸ¯ Design Pattern : Strategy (StratÃ©gie)</h3>

<p>
Le <strong>Pattern Strategy</strong> permet de dÃ©finir une famille d'algorithmes interchangeables. Chaque algorithme est encapsulÃ© dans une classe sÃ©parÃ©e, et ils peuvent Ãªtre Ã©changÃ©s Ã  la volÃ©e sans modifier le code client.
</p>

<div class="pourquoi">
<h4>â“ ProblÃ¨me Ã  RÃ©soudre</h4>

<p>
Comment permettre diffÃ©rentes faÃ§ons de configurer la grille (alÃ©atoire, canon, vide, etc.) sans remplir le Model de mÃ©thodes et de <code>if/else</code> ?
</p>

<p><strong>âŒ Approche NaÃ¯ve (Sans Pattern) :</strong></p>
<pre>
class LiveModel:
    def configure(self, type):
        if type == "random":
            # 20 lignes de code pour random
        elif type == "cannon":
            # 30 lignes de code pour cannon
        elif type == "empty":
            # 10 lignes de code pour empty
        elif type == "blinker":
            # 15 lignes de code pour blinker
        # ... encore plus de elif ...
</pre>

<p><strong>ProblÃ¨mes :</strong></p>
<ul>
<li>âŒ MÃ©thode Ã©norme et illisible</li>
<li>âŒ Ajouter une configuration nÃ©cessite de modifier LiveModel</li>
<li>âŒ Violation du principe Open/Closed (ouvert Ã  l'extension, fermÃ© Ã  la modification)</li>
<li>âŒ Impossible de rÃ©utiliser les configurations ailleurs</li>
</ul>

<p><strong>âœ… Solution : Pattern Strategy</strong></p>
<pre>
class LiveModel:
    def apply_configuration_strategy(self, strategy):
        strategy.apply(self)  # DÃ©lÃ©gation !
        self.notify_observers()

# Utilisation :
model.apply_configuration_strategy(RandomStrategy(0.25))
model.apply_configuration_strategy(CannonStrategy())
</pre>

<p><strong>Avantages :</strong></p>
<ul>
<li>âœ… Chaque configuration dans sa propre classe</li>
<li>âœ… Facile d'ajouter de nouvelles configurations sans modifier LiveModel</li>
<li>âœ… StratÃ©gies rÃ©utilisables et testables indÃ©pendamment</li>
<li>âœ… Code clair et maintenable</li>
</ul>
</div>
</div>

<pre>
class ConfigurationStrategy(ABC):
    """
    Interface abstraite pour les stratÃ©gies de configuration.

    <strong>RÃ´le :</strong>
    DÃ©finit le contrat pour toutes les stratÃ©gies de configuration
    de la grille. Chaque stratÃ©gie concrÃ¨te implÃ©mente apply().

    <strong>Exemples de stratÃ©gies concrÃ¨tes :</strong>
    - EmptyStrategy : Vide la grille
    - RandomStrategy : Configuration alÃ©atoire
    - CannonStrategy : Gosper Glider Gun
    - BlinkerStrategy : Pattern blinker (facile Ã  ajouter !)
    """

    @abstractmethod
    def apply(self, model):
        """
        Appliquer cette stratÃ©gie de configuration au modÃ¨le.

        Args:
            model (LiveModel): Le modÃ¨le Ã  configurer

        <strong>ResponsabilitÃ© :</strong>
        La stratÃ©gie modifie la grille du model selon son algorithme
        spÃ©cifique. Elle a accÃ¨s direct Ã  model.grid pour plus
        d'efficacitÃ©.

        <strong>Pattern de mise en Å“uvre typique :</strong>
        1. Vider la grille (ou partir d'une grille existante)
        2. Placer les cellules vivantes selon le pattern
        3. DÃ©finir l'Ã¢ge des cellules
        """
        pass
</pre>

<div class="explication">
<h4>ğŸ’¡ Principe Open/Closed</h4>

<p>
Le Pattern Strategy est une application directe du <strong>Principe Open/Closed</strong> (un des principes SOLID) :
</p>

<blockquote>
<p><em>"Les entitÃ©s logicielles (classes, modules, fonctions) doivent Ãªtre <strong>ouvertes Ã  l'extension</strong>, mais <strong>fermÃ©es Ã  la modification</strong>."</em></p>
</blockquote>

<p><strong>ConcrÃ¨tement :</strong></p>
<ul>
<li><strong>Ouvert Ã  l'extension</strong> : On peut ajouter de nouvelles stratÃ©gies (BlinkerStrategy, GliderStrategy, etc.)</li>
<li><strong>FermÃ© Ã  la modification</strong> : On ne modifie PAS LiveModel pour ajouter ces stratÃ©gies</li>
</ul>

<pre>
<strong>Pour ajouter un nouveau pattern (Blinker) :</strong>

# 1. CrÃ©er une nouvelle classe (EXTENSION)
class BlinkerStrategy(ConfigurationStrategy):
    def apply(self, model):
        EmptyStrategy().apply(model)
        model.grid[5][5].state = True
        model.grid[5][6].state = True
        model.grid[5][7].state = True
        # DÃ©finir les Ã¢ges...

# 2. Utiliser la nouvelle stratÃ©gie (PAS DE MODIFICATION)
model.apply_configuration_strategy(BlinkerStrategy())
</pre>

<p>
Aucune ligne de code dans <code>LiveModel</code> n'a Ã©tÃ© modifiÃ©e ! C'est la beautÃ© du Pattern Strategy.
</p>
</div>

<h2>3.3 StratÃ©gies ConcrÃ¨tes</h2>

<h3>3.3.1 EmptyStrategy - Vider la Grille</h3>

<pre>
class EmptyStrategy(ConfigurationStrategy):
    """
    StratÃ©gie concrÃ¨te : grille vide.

    <strong>UtilitÃ© :</strong>
    - UtilisÃ©e directement quand on veut vider la grille
    - UtilisÃ©e par d'autres stratÃ©gies comme point de dÃ©part

    <strong>Principe de rÃ©utilisation :</strong>
    RandomStrategy et CannonStrategy commencent par vider la grille.
    Au lieu de dupliquer le code, ils rÃ©utilisent EmptyStrategy.
    """

    def apply(self, model):
        """
        Vider complÃ¨tement la grille.

        <strong>Algorithme :</strong>
        1. Parcourir toutes les cellules
        2. Mettre state = False (morte)
        3. Mettre age = 0 (pas d'Ã¢ge)

        <strong>ComplexitÃ© :</strong>
        O(width Ã— height) - doit parcourir toute la grille
        """
        for row in range(model.height):
            for col in range(model.width):
                cell = model.grid[row][col]
                cell.state = False  # Morte
                cell.age = 0        # Ã‚ge remis Ã  zÃ©ro
</pre>

<div class="explication">
<h4>ğŸ’¡ Pourquoi AccÃ©der Directement Ã  model.grid ?</h4>

<p>
Normalement, l'encapsulation dicte qu'on devrait utiliser des mÃ©thodes comme <code>model.set_cell_state(row, col, False)</code>. Mais ici, on accÃ¨de directement Ã  <code>model.grid[row][col]</code>.
</p>

<p><strong>Pourquoi cette exception ?</strong></p>

<ol>
<li><strong>Performance</strong> : Les stratÃ©gies modifient beaucoup de cellules d'un coup. Passer par des mÃ©thodes ajouterait un overhead inutile.</li>

<li><strong>PrivilÃ¨ge spÃ©cial</strong> : Les stratÃ©gies sont des "amies" du Model. Elles font partie du mÃªme module et ont un accÃ¨s privilÃ©giÃ©.</li>

<li><strong>CohÃ©sion</strong> : Les stratÃ©gies et le Model sont fortement couplÃ©s par design. C'est une dÃ©cision architecturale consciente.</li>
</ol>

<p><strong>Analogie :</strong></p>
<p>
C'est comme un chirurgien qui a accÃ¨s aux organes internes d'un patient pendant une opÃ©ration. Normalement, personne ne touche les organes internes (encapsulation), mais le chirurgien a un privilÃ¨ge spÃ©cial car il sait ce qu'il fait.
</p>
</div>

<h3>3.3.2 RandomStrategy - Configuration AlÃ©atoire</h3>

<pre>
class RandomStrategy(ConfigurationStrategy):
    """
    StratÃ©gie concrÃ¨te : configuration alÃ©atoire.

    <strong>Requis par le professeur :</strong>
    Consigne 5 : "Proposer au dÃ©part une 'configuration alÃ©atoire' :
    25% des cellules vivantes au dÃ©part, dispersÃ©es alÃ©atoirement."

    <strong>ParamÃ©trable :</strong>
    Le pourcentage de cellules vivantes peut Ãªtre ajustÃ©.
    """

    def __init__(self, alive_percentage=0.25):
        """
        Initialiser la stratÃ©gie alÃ©atoire.

        Args:
            alive_percentage (float): Pourcentage de cellules vivantes
                                     (0.0 = toutes mortes, 1.0 = toutes vivantes)

        <strong>Valeur par dÃ©faut : 0.25 (25%)</strong>
        Pourquoi 25% ?
        - RecommandÃ© par le professeur
        - ExpÃ©rimentalement, 25% donne des configurations intÃ©ressantes
        - Trop bas (<10%) : La plupart des cellules meurent rapidement
        - Trop haut (>50%) : Congestion, tout meurt par surpopulation
        - 20-30% : Bon Ã©quilibre, patterns Ã©mergents
        """
        self.__alive_percentage = alive_percentage

    def apply(self, model):
        """
        CrÃ©er une configuration alÃ©atoire.

        <strong>Algorithme :</strong>
        1. Vider la grille (rÃ©utilisation d'EmptyStrategy)
        2. Pour chaque cellule :
           a. GÃ©nÃ©rer un nombre alÃ©atoire entre 0 et 1
           b. Si < alive_percentage : cellule vivante (Ã¢ge = 1)
           c. Sinon : cellule morte (dÃ©jÃ  morte aprÃ¨s l'Ã©tape 1)

        <strong>Distribution :</strong>
        La distribution est uniforme. Chaque cellule a la mÃªme
        probabilitÃ© d'Ãªtre vivante, indÃ©pendamment de sa position.

        <strong>AlÃ©atoire vs Pseudo-alÃ©atoire :</strong>
        Python utilise random.random() qui est pseudo-alÃ©atoire
        (gÃ©nÃ©rateur Mersenne Twister). Suffisant pour un jeu.
        """
        # Commencer avec une grille vide (rÃ©utilisation !)
        EmptyStrategy().apply(model)

        # Placer des cellules vivantes alÃ©atoirement
        for row in range(model.height):
            for col in range(model.width):
                # random.random() retourne un float dans [0.0, 1.0)
                if random.random() < self.__alive_percentage:
                    cell = model.grid[row][col]
                    cell.state = True  # Vivante
                    cell.age = 1       # Nouveau-nÃ©e (rouge)
</pre>

<div class="exemple">
<h4>ğŸ“Š Exemple Concret</h4>

<p><strong>Grille 40Ã—40 avec 25% de cellules vivantes :</strong></p>

<pre>
Total de cellules : 40 Ã— 40 = 1600 cellules

Cellules vivantes attendues : 1600 Ã— 0.25 = 400 cellules

Avec random.random() :
- Si random() retourne 0.15 â†’ 0.15 < 0.25 â†’ Cellule VIVANTE âœ“
- Si random() retourne 0.73 â†’ 0.73 < 0.25 â†’ Cellule MORTE âœ—
- Si random() retourne 0.08 â†’ 0.08 < 0.25 â†’ Cellule VIVANTE âœ“
- Si random() retourne 0.50 â†’ 0.50 < 0.25 â†’ Cellule MORTE âœ—
- etc.
</pre>

<p><strong>RÃ©sultat visuel (R=rouge=nouveau-nÃ©e) :</strong></p>
<pre>
. . R . . . R . R . . . . . R . . . . .
. . . . R . . . . . R R . . . . . R . .
R . . . . . . . . R . . . . R . . . . .
. . . R . . R . . . . . . R . . . . R .
. R . . . . . R . . . . . . . . R . . .
...
</pre>

<p>
Au premier affichage, toutes les cellules vivantes sont <strong>rouges</strong> (Ã¢ge=1). AprÃ¨s quelques gÃ©nÃ©rations, on verra apparaÃ®tre du jaune, du vert et du bleu selon la stabilitÃ© des structures qui Ã©mergent.
</p>
</div>

<h3>3.3.3 CannonStrategy - Le Gosper Glider Gun</h3>

<pre>
class CannonStrategy(ConfigurationStrategy):
    """
    StratÃ©gie concrÃ¨te : Gosper Glider Gun.

    <strong>Histoire :</strong>
    Le Gosper Glider Gun a Ã©tÃ© dÃ©couvert en 1970 par Bill Gosper.
    C'est la premiÃ¨re structure dÃ©couverte qui croÃ®t indÃ©finiment.
    Il gÃ©nÃ¨re un nouveau glider toutes les 30 gÃ©nÃ©rations.

    <strong>Importance :</strong>
    Ce pattern a prouvÃ© que le Jeu de la Vie pouvait avoir une
    croissance infinie, contredisant une conjecture de John Conway.
    Bill Gosper a gagnÃ© 50$ de Conway pour cette dÃ©couverte !
    """

    def apply(self, model):
        """
        Configurer le Gosper Glider Gun.

        <strong>Structure du pattern :</strong>
        Le Gosper Glider Gun est composÃ© de 36 cellules disposÃ©es
        en trois parties :

        1. CarrÃ© gauche (4 cellules) : GÃ©nÃ©rateur stable
        2. Partie centrale (10 cellules) : Le "canon" qui tire
        3. Reflecteur droit (22 cellules) : RÃ©flÃ©chit et Ã©met les gliders

        <strong>CoordonnÃ©es :</strong>
        Les coordonnÃ©es ci-dessous sont les positions standards
        du Gosper Glider Gun, dÃ©couvertes par Bill Gosper.
        """
        # Commencer avec une grille vide
        EmptyStrategy().apply(model)

        # Pattern du Gosper Glider Gun (36 cellules)
        # Format : (row, col) en indices standards
        pattern = [
            # CarrÃ© gauche (gÃ©nÃ©rateur stable)
            # Ces 4 cellules forment un "bloc" - une structure stable
            (5, 1), (5, 2),
            (6, 1), (6, 2),

            # Partie centrale gauche (le "canon")
            # Ces cellules oscillent et gÃ©nÃ¨rent les gliders
            (5, 11), (6, 11), (7, 11),  # Ligne verticale
            (4, 12), (8, 12),            # CÃ´tÃ©s
            (3, 13), (9, 13),            # Extension
            (3, 14), (9, 14),            # Extension
            (6, 15),                     # Centre
            (4, 16), (8, 16),            # CÃ´tÃ©s
            (5, 17), (6, 17), (7, 17),  # Ligne verticale
            (6, 18),                     # Sortie

            # Reflecteur droit
            # Ces cellules rÃ©flÃ©chissent et stabilisent
            (3, 21), (4, 21), (5, 21),  # Ligne verticale
            (3, 22), (4, 22), (5, 22),  # Ligne verticale
            (2, 23), (6, 23),            # Bords
            (1, 25), (2, 25), (6, 25), (7, 25),  # Extension

            # CarrÃ© droit (absorbeur)
            # Ces 4 cellules forment un autre "bloc"
            (3, 35), (4, 35),
            (3, 36), (4, 36)
        ]

        # Placer chaque cellule du pattern
        for row, col in pattern:
            # VÃ©rifier que la cellule est dans la grille
            # (important si la grille est plus petite que 40Ã—40)
            if 0 <= row < model.height and 0 <= col < model.width:
                cell = model.grid[row][col]
                cell.state = True  # Vivante
                cell.age = 1       # Nouveau-nÃ©e (toutes rouges au dÃ©but)
</pre>

<div class="explication">
<h4>ğŸ’¡ Visualisation du Gosper Glider Gun</h4>

<p><strong>Au dÃ©marrage (GÃ©nÃ©ration 0) :</strong></p>
<pre>
  CarrÃ©        Canon              Reflecteur      CarrÃ©
 gauche                                          droit
    â–ˆâ–ˆ                                            â–ˆâ–ˆ
    â–ˆâ–ˆ            â–ˆâ–ˆâ–ˆ                            â–ˆâ–ˆ
              â–ˆ       â–ˆ
             â–ˆ         â–ˆ            â–ˆâ–ˆâ–ˆ
             â–ˆ         â–ˆ           â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
                â–ˆ                 â–ˆâ–ˆ    â–ˆâ–ˆ
              â–ˆ       â–ˆ
                â–ˆâ–ˆâ–ˆ
                 â–ˆ
</pre>

<p><strong>AprÃ¨s quelques gÃ©nÃ©rations :</strong></p>
<ul>
<li>Le <strong>canon</strong> oscille (cellules rouges/jaunes)</li>
<li>Des <strong>gliders</strong> sont Ã©mis pÃ©riodiquement (se dÃ©placent en diagonale)</li>
<li>Le <strong>carrÃ© gauche</strong> reste stable (bleu)</li>
<li>Le <strong>reflecteur</strong> oscille lÃ©gÃ¨rement (vert/bleu)</li>
</ul>

<p><strong>SystÃ¨me de couleurs avec l'Ã¢ge :</strong></p>
<pre>
ğŸ”´ Rouge (Ã¢ge=1)  : Cellules du canon qui naissent/meurent constamment
ğŸŸ¡ Jaune (Ã¢ge 2-3): Cellules oscillantes du canon
ğŸŸ¢ Vert (Ã¢ge 4-7) : Parties semi-stables du reflecteur
ğŸ”µ Bleu (Ã¢ge 8+)  : CarrÃ©s gauche/droit qui ne changent jamais
</pre>

<p>
Cette visualisation par couleur est <strong>pÃ©dagogique</strong> : elle montre clairement quelles parties du pattern sont stables et lesquelles sont dynamiques.
</p>
</div>

<div class="important">
<h4>âš ï¸ Note sur les CoordonnÃ©es</h4>

<p>
Les coordonnÃ©es du Gosper Glider Gun sont des <strong>indices standards</strong> (0, 1, 2, 3...), PAS des pixels.
</p>

<pre>
âŒ Code procÃ©dural (incorrect) :
pattern = [(5*c, 1*c), (5*c, 2*c), ...]  # Multiplications par c !

âœ… Notre code (correct) :
pattern = [(5, 1), (5, 2), ...]  # Indices purs
</pre>

<p>
Cette sÃ©paration est <strong>cruciale</strong>. Le Model ne connaÃ®t pas les pixels. Si on veut changer la taille des cellules de 10px Ã  20px, le Model ne change pas. Seule la View change.
</p>
</div>

<h2>3.4 Classe LiveCell - La Cellule Individuelle</h2>

<div class="concept">
<h3>ğŸ”¬ LiveCell : L'Atome de l'Application</h3>

<p>
<strong>LiveCell</strong> est la plus petite unitÃ© de notre application. Chaque cellule est un <strong>objet indÃ©pendant</strong> qui encapsule son Ã©tat.
</p>

<p><strong>Principe de conception :</strong></p>
<p>
Au lieu d'avoir une simple matrice de boolÃ©ens (<code>grid[row][col] = True/False</code>), on crÃ©e une <strong>classe dÃ©diÃ©e</strong>. Pourquoi ?
</p>

<ol>
<li><strong>Encapsulation</strong> : Chaque cellule gÃ¨re son propre Ã©tat</li>
<li><strong>ExtensibilitÃ©</strong> : Facile d'ajouter des propriÃ©tÃ©s (Ã¢ge, couleur, etc.)</li>
<li><strong>ClartÃ©</strong> : <code>cell.state</code> est plus clair que <code>grid[row][col]</code></li>
<li><strong>Polymorphisme futur</strong> : On pourrait avoir diffÃ©rents types de cellules</li>
</ol>
</div>

<pre>
class LiveCell:
    """
    ReprÃ©sente une cellule individuelle dans la grille.

    <strong>ResponsabilitÃ©s :</strong>
    - Stocker l'Ã©tat (vivante/morte)
    - Stocker le nombre de voisins (pour les rÃ¨gles)
    - Stocker l'Ã¢ge (pour les couleurs)

    <strong>Encapsulation :</strong>
    Tous les attributs sont privÃ©s (__attribut) avec property decorators.
    C'est un exemple parfait d'encapsulation en POO.

    <strong>Design Decision : Objet vs Simple Boolean</strong>

    âŒ Approche simple (grille de boolÃ©ens) :
    grid = [[False] * width for _ in range(height)]

    âœ… Approche objet (grille de LiveCell) :
    grid = [[LiveCell() for _ in range(width)] for _ in range(height)]

    <strong>Avantages de l'approche objet :</strong>
    - Plus facile d'ajouter des attributs (Ã¢ge, couleur, historique...)
    - Encapsulation : on contrÃ´le l'accÃ¨s via properties
    - CohÃ©rence : toutes les donnÃ©es d'une cellule regroupÃ©es
    - ExtensibilitÃ© : on pourrait crÃ©er des sous-classes (CelluleSpeciale)
    """

    def __init__(self, state=False):
        """
        Initialiser une cellule.

        Args:
            state (bool): Ã‰tat initial (False = morte, True = vivante)

        <strong>Valeur par dÃ©faut : False</strong>
        Pourquoi morte par dÃ©faut ?
        - La grille commence vide dans la plupart des cas
        - C'est l'Ã©tat "neutre" d'une cellule
        - Les configurations (Random, Cannon) mettront les cellules vivantes

        <strong>Attributs privÃ©s :</strong>
        Les trois attributs sont privÃ©s (prÃ©fixe __) pour l'encapsulation.
        L'accÃ¨s se fait via @property decorators.
        """
        self.__state = state            # Vivante (True) ou morte (False)
        self.__neighbors_count = 0      # Nombre de voisins vivants (0-8)
        self.__age = 0                  # GÃ©nÃ©rations vivantes (0, 1, 2...)
</pre>

<div class="explication">
<h4>ğŸ’¡ Pourquoi Trois Attributs ?</h4>

<p><strong>1. __state (Ã‰tat vivant/mort)</strong></p>
<p>
C'est l'attribut fondamental. Il dÃ©termine si la cellule est vivante ou morte.
</p>
<ul>
<li><strong>Type</strong> : <code>bool</code> (True/False)</li>
<li><strong>Utilisation</strong> : RÃ¨gles de Conway, affichage</li>
<li><strong>Modifiable</strong> : Oui, change Ã  chaque gÃ©nÃ©ration ou toggle</li>
</ul>

<p><strong>2. __neighbors_count (Nombre de voisins)</strong></p>
<p>
Stocke le nombre de voisins vivants (0 Ã  8). Pourquoi le stocker ?
</p>
<ul>
<li><strong>Performance</strong> : CalculÃ© une fois, utilisÃ© plusieurs fois</li>
<li><strong>ClartÃ©</strong> : On voit immÃ©diatement combien de voisins chaque cellule a</li>
<li><strong>DÃ©bogage</strong> : Facilite la vÃ©rification des calculs</li>
</ul>

<p><strong>Alternative (sans stockage) :</strong></p>
<pre>
# Recalculer Ã  chaque fois (moins efficace)
neighbors = count_neighbors(grid, row, col)
if neighbors == 3:
    # ...
neighbors = count_neighbors(grid, row, col)  # Recalcul !
# ...
</pre>

<p><strong>Avec stockage (notre approche) :</strong></p>
<pre>
# Calculer une fois
cell.neighbors_count = count_neighbors(grid, row, col)
# Utiliser plusieurs fois sans recalcul
if cell.neighbors_count == 3:
    # ...
if cell.neighbors_count <= 1:
    # ...
</pre>

<p><strong>3. __age (Ã‚ge de la cellule)</strong></p>
<p>
FonctionnalitÃ© supplÃ©mentaire pour la visualisation. L'Ã¢ge permet d'afficher des couleurs diffÃ©rentes selon la stabilitÃ©.
</p>
<ul>
<li><strong>Ã‚ge = 1</strong> : Cellule vient de naÃ®tre â†’ ğŸ”´ Rouge</li>
<li><strong>Ã‚ge 2-3</strong> : Cellule jeune â†’ ğŸŸ¡ Jaune</li>
<li><strong>Ã‚ge 4-7</strong> : Cellule stable â†’ ğŸŸ¢ Vert</li>
<li><strong>Ã‚ge 8+</strong> : Cellule trÃ¨s stable â†’ ğŸ”µ Bleu</li>
</ul>

<p><strong>Valeur pÃ©dagogique :</strong></p>
<p>
Ce systÃ¨me de couleurs permet de <strong>visualiser la stabilitÃ©</strong> des structures du Game of Life. Les Ã©tudiants peuvent voir immÃ©diatement :
</p>
<ul>
<li>Les patterns chaotiques (rouge/jaune clignotant)</li>
<li>Les oscillateurs (vert/bleu rÃ©gulier)</li>
<li>Les structures stables (bleu constant)</li>
</ul>
</div>

<pre>
    def __str__(self):
        """
        ReprÃ©sentation en chaÃ®ne pour le dÃ©bogage.

        <strong>MÃ©thode magique Python :</strong>
        __str__() est appelÃ©e automatiquement par str(obj) et print(obj).
        C'est une des "mÃ©thodes magiques" (dunder methods = double underscore).

        Returns:
            str: "1" si vivante, "0" si morte

        <strong>Utilisation :</strong>
        Permet d'afficher facilement la grille en mode texte :

        >>> cell1 = LiveCell(True)
        >>> cell2 = LiveCell(False)
        >>> print(cell1)
        1
        >>> print(cell2)
        0

        >>> # Afficher toute la grille :
        >>> for row in grid:
        >>>     print(''.join(str(cell) for cell in row))
        000111000
        001010100
        000111000

        <strong>Pourquoi "1" et "0" ?</strong>
        Convention classique : 1 = vivant, 0 = mort
        Simple et universel
        """
        return "1" if self.__state else "0"
</pre>

<h3>3.4.1 Properties - AccÃ¨s ContrÃ´lÃ© aux Attributs</h3>

<div class="concept">
<h3>ğŸ­ Les Property Decorators en Python</h3>

<p>
Les <strong>property decorators</strong> (<code>@property</code>) sont une fonctionnalitÃ© puissante de Python qui permet d'accÃ©der aux attributs privÃ©s comme s'ils Ã©taient publics, tout en gardant le contrÃ´le.
</p>

<h4>Le ProblÃ¨me sans Properties</h4>

<pre>
<strong>âŒ Approche 1 : Attributs publics (mauvais)</strong>

class LiveCell:
    def __init__(self):
        self.state = False  # Public !

# ProblÃ¨me : accÃ¨s direct, pas de contrÃ´le
cell.state = "blabla"  # Erreur ! Devrait Ãªtre bool
cell.state = -1        # Aucun sens !
</pre>

<pre>
<strong>âŒ Approche 2 : Getters/Setters classiques (verbeux)</strong>

class LiveCell:
    def __init__(self):
        self.__state = False

    def get_state(self):
        return self.__state

    def set_state(self, value):
        self.__state = value

# Utilisation verbeuse :
if cell.get_state():        # Moche
    cell.set_state(False)   # Vraiment moche
</pre>

<pre>
<strong>âœ… Approche 3 : Property Decorators (Ã©lÃ©gant)</strong>

class LiveCell:
    def __init__(self):
        self.__state = False

    @property
    def state(self):
        return self.__state

    @state.setter
    def state(self, value):
        self.__state = value

# Utilisation Ã©lÃ©gante :
if cell.state:        # âœ“ Naturel
    cell.state = False  # âœ“ Pythonique
</pre>

<h4>Avantages des Properties</h4>

<ol>
<li><strong>Syntaxe naturelle</strong> : <code>cell.state</code> au lieu de <code>cell.get_state()</code></li>
<li><strong>Encapsulation</strong> : L'attribut reste privÃ©, mais l'accÃ¨s est contrÃ´lÃ©</li>
<li><strong>Validation possible</strong> : On peut ajouter de la logique dans le setter</li>
<li><strong>Ã‰volution facile</strong> : On peut changer l'implÃ©mentation interne sans casser le code client</li>
<li><strong>Pythonique</strong> : C'est la faÃ§on "Python" de faire</li>
</ol>
</div>

<pre>
    <strong># Properties pour l'Ã©tat</strong>

    @property
    def state(self):
        """
        Obtenir l'Ã©tat de la cellule.

        <strong>DÃ©corateur @property :</strong>
        Transforme cette mÃ©thode en "getter". Permet d'accÃ©der Ã 
        self.__state via cell.state (sans parenthÃ¨ses).

        Returns:
            bool: True si vivante, False si morte

        <strong>Exemple d'utilisation :</strong>
        >>> cell = LiveCell(True)
        >>> if cell.state:  # Appelle automatiquement cette mÃ©thode
        >>>     print("Cellule vivante")

        <strong>Pourquoi pas d'attribut public ?</strong>
        On pourrait faire self.state directement, mais :
        - L'encapsulation est rompue
        - Impossible d'ajouter de la validation plus tard
        - Impossible de logger l'accÃ¨s
        - Pas de contrÃ´le sur les modifications
        """
        return self.__state

    @state.setter
    def state(self, value):
        """
        DÃ©finir l'Ã©tat de la cellule.

        <strong>DÃ©corateur @state.setter :</strong>
        Transforme cette mÃ©thode en "setter". Permet de modifier
        self.__state via cell.state = value.

        Args:
            value (bool): Nouvel Ã©tat

        <strong>Exemple d'utilisation :</strong>
        >>> cell = LiveCell()
        >>> cell.state = True  # Appelle automatiquement cette mÃ©thode

        <strong>PossibilitÃ© de validation :</strong>
        On pourrait ajouter de la validation ici :

        if not isinstance(value, bool):
            raise TypeError("state must be a boolean")

        Mais pour la performance, on fait confiance au code
        qui appelle (contrat implicite).
        """
        self.__state = value
</pre>

<div class="exemple">
<h4>ğŸ“ Exemple Concret d'Utilisation des Properties</h4>

<pre>
<strong>Sans properties (verbose) :</strong>

cell = LiveCell()
if cell.get_state() == True:
    cell.set_state(False)
count = cell.get_neighbors_count()

<strong>Avec properties (Ã©lÃ©gant) :</strong>

cell = LiveCell()
if cell.state:              # Plus naturel
    cell.state = False      # Plus lisible
count = cell.neighbors_count  # Plus Pythonique
</pre>

<p>
La diffÃ©rence semble minime, mais dans un code de plusieurs milliers de lignes, cette lisibilitÃ© compte Ã©normÃ©ment.
</p>
</div>

<pre>
    <strong># Properties pour le compte de voisins</strong>

    @property
    def neighbors_count(self):
        """
        Obtenir le nombre de voisins vivants.

        <strong>Utilisation :</strong>
        Cette valeur est calculÃ©e par LiveModel.__update_neighbors_count()
        avant d'appliquer les rÃ¨gles de Conway.

        Returns:
            int: Nombre de voisins vivants (0 Ã  8)

        <strong>Les 8 voisins possibles :</strong>
        â”Œâ”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”
        â”‚ 1 â”‚ 2 â”‚ 3 â”‚  Haut-gauche, Haut, Haut-droite
        â”œâ”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¤
        â”‚ 4 â”‚ X â”‚ 5 â”‚  Gauche, CELLULE, Droite
        â”œâ”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¤
        â”‚ 6 â”‚ 7 â”‚ 8 â”‚  Bas-gauche, Bas, Bas-droite
        â””â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”˜

        <strong>Cas particuliers :</strong>
        - Coin : 3 voisins maximum
        - Bord : 5 voisins maximum
        - Centre : 8 voisins maximum
        """
        return self.__neighbors_count

    @neighbors_count.setter
    def neighbors_count(self, value):
        """
        DÃ©finir le nombre de voisins.

        <strong>Qui appelle cette mÃ©thode ?</strong>
        Uniquement LiveModel.__update_neighbors_count().
        C'est une mÃ©thode "package-private" en quelque sorte.

        Args:
            value (int): Nouveau compte de voisins (0-8)

        <strong>Pas de validation stricte :</strong>
        On pourrait vÃ©rifier 0 <= value <= 8, mais on fait
        confiance au Model. C'est un compromis performance/sÃ©curitÃ©.
        """
        self.__neighbors_count = value
</pre>

<pre>
    <strong># Properties pour l'Ã¢ge</strong>

    @property
    def age(self):
        """
        Obtenir l'Ã¢ge de la cellule (gÃ©nÃ©rations vivantes).

        <strong>SystÃ¨me d'Ã¢ge pour les couleurs :</strong>

        L'Ã¢ge reprÃ©sente combien de gÃ©nÃ©rations la cellule a
        Ã©tÃ© vivante de maniÃ¨re consÃ©cutive.

        <strong>RÃ¨gles de mise Ã  jour :</strong>
        - Cellule naÃ®t (morte â†’ vivante) : Ã¢ge = 1
        - Cellule survit (vivante â†’ vivante) : Ã¢ge += 1
        - Cellule meurt (vivante â†’ morte) : Ã¢ge = 0
        - Cellule reste morte : Ã¢ge = 0

        <strong>Correspondance couleurs :</strong>
        - Ã¢ge = 1   : ğŸ”´ Rouge    (nouveau-nÃ©e)
        - Ã¢ge = 2-3 : ğŸŸ¡ Jaune   (jeune)
        - Ã¢ge = 4-7 : ğŸŸ¢ Vert    (stable)
        - Ã¢ge â‰¥ 8   : ğŸ”µ Bleu    (trÃ¨s stable)

        Returns:
            int: Ã‚ge de la cellule (0 = morte, 1+ = vivante)

        <strong>Exemples concrets :</strong>

        # Blinker (oscillateur pÃ©riode 2)
        GÃ©nÃ©ration 0 : â”€â”€â”€ (horizontal, Ã¢ge=1, rouge)
        GÃ©nÃ©ration 1 : â”‚ (vertical, Ã¢ge=1, rouge)
        GÃ©nÃ©ration 2 : â”€â”€â”€ (horizontal, Ã¢ge=1, rouge)
        â†’ Toujours rouge car les cellules meurent et renaissent

        # Block (still life)
        â–ˆâ–ˆ
        â–ˆâ–ˆ
        GÃ©nÃ©ration 0-100 : Aucun changement
        â†’ Bleu aprÃ¨s 8 gÃ©nÃ©rations (trÃ¨s stable)

        # Glider (spaceship)
        Les cellules du glider changent constamment
        â†’ MÃ©lange de rouge/jaune/vert selon les positions
        """
        return self.__age

    @age.setter
    def age(self, value):
        """
        DÃ©finir l'Ã¢ge de la cellule.

        <strong>Qui modifie l'Ã¢ge ?</strong>
        - LiveModel.evolve() : Met Ã  jour l'Ã¢ge Ã  chaque gÃ©nÃ©ration
        - LiveModel.toggle_cell() : DÃ©finit l'Ã¢ge lors du toggle manuel
        - Les stratÃ©gies : DÃ©finissent l'Ã¢ge lors de la configuration

        Args:
            value (int): Nouvel Ã¢ge
        """
        self.__age = value
</pre>

<div class="important">
<h4>âš ï¸ Importance de l'Ordre des Decorators</h4>

<p>
Il est <strong>crucial</strong> que le <code>@property</code> soit dÃ©fini <strong>avant</strong> le <code>@property_name.setter</code>.
</p>

<pre>
<strong>âœ… Ordre correct :</strong>

@property
def state(self):
    return self.__state

@state.setter  # â† RÃ©fÃ©rence le @property ci-dessus
def state(self, value):
    self.__state = value

<strong>âŒ Ordre incorrect (erreur) :</strong>

@state.setter  # â† Erreur ! 'state' n'existe pas encore
def state(self, value):
    self.__state = value

@property
def state(self):
    return self.__state
</pre>

<p>
Python crÃ©e d'abord l'objet <code>property</code> avec le getter, puis y ajoute le setter via <code>@state.setter</code>. L'ordre est donc important.
</p>
</div>

<h2>3.5 Classe LiveModel - Le ModÃ¨le Principal</h2>

<div class="concept">
<h3>ğŸ›ï¸ LiveModel : Le CÅ“ur du Jeu de la Vie</h3>

<p>
<strong>LiveModel</strong> est la classe la plus complexe et la plus importante du projet. Elle contient toute la <strong>logique mÃ©tier</strong> du Jeu de la Vie.
</p>

<p><strong>HiÃ©rarchie de classes :</strong></p>
<pre>
Observable (ABC)
    â†‘
    â”‚ hÃ©rite de
    â”‚
LiveModel
</pre>

<p><strong>ResponsabilitÃ©s multiples :</strong></p>

<ol>
<li><strong>Gestion de l'Ã©tat</strong>
    <ul>
        <li>Stocke la grille de cellules (composition)</li>
        <li>Maintient le compteur de gÃ©nÃ©rations</li>
        <li>GÃ¨re les dimensions (largeur, hauteur)</li>
    </ul>
</li>

<li><strong>Logique du jeu</strong>
    <ul>
        <li>Calcule les voisins de chaque cellule</li>
        <li>Applique les trois rÃ¨gles de Conway</li>
        <li>Fait Ã©voluer la grille d'une gÃ©nÃ©ration</li>
    </ul>
</li>

<li><strong>Pattern Observer</strong>
    <ul>
        <li>Maintient une liste d'observateurs</li>
        <li>Notifie les observateurs aprÃ¨s chaque changement</li>
        <li>ImplÃ©mente Observable (ABC)</li>
    </ul>
</li>

<li><strong>Pattern Strategy</strong>
    <ul>
        <li>Accepte diffÃ©rentes stratÃ©gies de configuration</li>
        <li>DÃ©lÃ¨gue la configuration aux stratÃ©gies</li>
    </ul>
</li>

<li><strong>Pattern Singleton</strong>
    <ul>
        <li>Fournit une mÃ©thode singleton() pour instance unique</li>
        <li>Stocke l'instance unique dans un attribut de classe</li>
    </ul>
</li>
</ol>
</div>

<h3>3.5.1 Structure et Initialisation</h3>

<pre>
class LiveModel(Observable):
    """
    ModÃ¨le principal du Jeu de la Vie.

    <strong>HÃ©ritage :</strong>
    HÃ©rite d'Observable pour implÃ©menter le Pattern Observer.
    Doit donc implÃ©menter : attach(), detach(), notify_observers()

    <strong>Attribut de classe pour Singleton Pattern :</strong>
    """

    __instance = None  # Attribut de classe (partagÃ© entre toutes les instances)
</pre>

<div class="explication">
<h4>ğŸ’¡ Attribut de Classe vs Attribut d'Instance</h4>

<p><strong>Attribut de classe :</strong></p>
<pre>
class LiveModel:
    __instance = None  # â† DÃ©fini au niveau de la CLASSE

    def __init__(self):
        self.__grid = []  # â† DÃ©fini au niveau de l'INSTANCE
</pre>

<p><strong>DiffÃ©rences :</strong></p>

<table>
<tr>
    <th>Aspect</th>
    <th>Attribut de Classe</th>
    <th>Attribut d'Instance</th>
</tr>
<tr>
    <td><strong>DÃ©finition</strong></td>
    <td>Au niveau de la classe</td>
    <td>Dans __init__ avec self</td>
</tr>
<tr>
    <td><strong>Partage</strong></td>
    <td>PartagÃ© entre toutes les instances</td>
    <td>Unique Ã  chaque instance</td>
</tr>
<tr>
    <td><strong>AccÃ¨s</strong></td>
    <td>ClassName.__instance ou self.__class__.__instance</td>
    <td>self.__grid</td>
</tr>
<tr>
    <td><strong>Utilisation</strong></td>
    <td>DonnÃ©es partagÃ©es, singleton, constantes</td>
    <td>Ã‰tat spÃ©cifique Ã  l'objet</td>
</tr>
</table>

<p><strong>Exemple concret :</strong></p>
<pre>
model1 = LiveModel(10, 10)
model2 = LiveModel(20, 20)

# Attributs d'instance (diffÃ©rents)
print(model1.width)  # 10
print(model2.width)  # 20

# Attribut de classe (partagÃ©)
print(LiveModel._LiveModel__instance)  # MÃªme valeur pour tous
</pre>

<p>
Pour le Singleton Pattern, on utilise un attribut de classe car on veut <strong>une seule instance partagÃ©e</strong> pour toute l'application.
</p>
</div>

<h3>3.5.2 Pattern Singleton - MÃ©thode de Classe</h3>

<pre>
    @classmethod
    def singleton(cls, width=40, height=40):
        """
        SINGLETON PATTERN: Obtenir l'instance unique du Model.

        <strong>Qu'est-ce qu'un Singleton ?</strong>

        Le Singleton est un pattern de crÃ©ation qui garantit qu'une
        classe n'a qu'UNE SEULE instance dans toute l'application,
        et fournit un point d'accÃ¨s global Ã  cette instance.

        <strong>Pourquoi @classmethod ?</strong>

        @classmethod est un dÃ©corateur qui transforme une mÃ©thode
        normale en mÃ©thode de classe. DiffÃ©rences :

        - MÃ©thode normale : def foo(self, ...) â†’ reÃ§oit l'instance
        - MÃ©thode de classe : def foo(cls, ...) â†’ reÃ§oit la CLASSE

        Cela permet d'appeler la mÃ©thode sans avoir d'instance :
        model = LiveModel.singleton()  # Pas besoin d'instance existante

        <strong>Comment Ã§a marche ?</strong>

        1. Premier appel :
           - cls.__instance est None
           - On crÃ©e une nouvelle instance : cls(width, height)
           - On la stocke dans cls.__instance
           - On la retourne

        2. Appels suivants :
           - cls.__instance n'est plus None
           - On retourne l'instance existante (PAS de nouvelle crÃ©ation)
           - Les paramÃ¨tres width/height sont ignorÃ©s

        Args:
            width (int): Largeur (seulement au premier appel)
            height (int): Hauteur (seulement au premier appel)

        Returns:
            LiveModel: L'instance unique

        <strong>Exemple d'utilisation :</strong>

        >>> model1 = LiveModel.singleton(40, 40)
        >>> print(id(model1))
        140234567890

        >>> model2 = LiveModel.singleton(50, 50)  # IgnorÃ© !
        >>> print(id(model2))
        140234567890  # MÃªme ID = mÃªme objet

        >>> assert model1 is model2  # True

        <strong>Quand utiliser le Singleton ?</strong>

        - Quand on veut garantir qu'il n'y a qu'un seul Ã©tat de jeu
        - Pour un point d'accÃ¨s global (attention : peut Ãªtre considÃ©rÃ©
          comme une variable globale dÃ©guisÃ©e)
        - Dans notre cas : optionnel, on peut aussi utiliser __init__

        <strong>Alternative sans Singleton :</strong>

        model = LiveModel(40, 40)  # Instance normale
        # On passe model explicitement partout oÃ¹ on en a besoin
        """
        if cls.__instance is None:
            # CrÃ©er l'instance unique
            cls.__instance = cls(width, height)
        return cls.__instance
</pre>

<div class="pourquoi">
<h4>â“ Singleton : Avantages et InconvÃ©nients</h4>

<p><strong>âœ… Avantages :</strong></p>
<ul>
<li><strong>Une seule instance garantie</strong> : Pas de duplication d'Ã©tat</li>
<li><strong>Point d'accÃ¨s global</strong> : Accessible partout sans passer de rÃ©fÃ©rences</li>
<li><strong>Initialisation paresseuse</strong> : CrÃ©Ã© seulement quand nÃ©cessaire</li>
<li><strong>Ã‰conomie mÃ©moire</strong> : Une seule grille en mÃ©moire</li>
</ul>

<p><strong>âŒ InconvÃ©nients :</strong></p>
<ul>
<li><strong>Ã‰tat global cachÃ©</strong> : Peut Ãªtre vu comme une variable globale dÃ©guisÃ©e</li>
<li><strong>Difficile Ã  tester</strong> : Tests interdÃ©pendants si ils partagent l'instance</li>
<li><strong>Couplage implicite</strong> : DÃ©pendance cachÃ©e au Singleton</li>
<li><strong>ProblÃ¨mes de concurrence</strong> : Pas thread-safe sans synchronisation</li>
</ul>

<p><strong>Notre approche : Singleton optionnel</strong></p>
<p>
Dans ce projet, le Singleton est <strong>implÃ©mentÃ© mais pas utilisÃ©</strong> par dÃ©faut. C'est un <strong>bonus</strong> qui montre notre connaissance du pattern, mais on prÃ©fÃ¨re passer le model explicitement dans main.py :
</p>

<pre>
# main.py - Approche prÃ©fÃ©rÃ©e (explicit)
model = LiveModel(40, 40)
controller = LiveController(model, view)

# Alternative Singleton (global)
model = LiveModel.singleton(40, 40)
controller = LiveController(model, view)
</pre>

<p>
L'approche explicite est <strong>plus claire</strong> et <strong>plus testable</strong>.
</p>
</div>

<h3>3.5.3 Constructeur __init__</h3>

<pre>
    def __init__(self, width=40, height=40):
        """
        Initialiser le modÃ¨le du Jeu de la Vie.

        <strong>Ordre d'initialisation (IMPORTANT) :</strong>

        1. Dimensions (width, height)
           â†’ NÃ©cessaires pour crÃ©er la grille

        2. Compteur de gÃ©nÃ©ration
           â†’ Commence Ã  0

        3. Structures de donnÃ©es vides (grid, observers)
           â†’ PrÃ©paration avant remplissage

        4. CrÃ©ation de la grille
           â†’ Remplit grid avec des LiveCell

        Cet ordre est CRITIQUE. Si on crÃ©ait la grille avant de
        dÃ©finir les dimensions, on aurait une erreur.

        Args:
            width (int): Largeur en CELLULES (pas pixels !)
            height (int): Hauteur en CELLULES

        <strong>Valeurs par dÃ©faut : 40Ã—40</strong>

        Pourquoi 40Ã—40 ?
        - Assez grand pour des patterns intÃ©ressants
        - Le Gosper Glider Gun nÃ©cessite au moins 38 colonnes
        - Pas trop grand (performance sur vieux ordinateurs)
        - Multiple de 10 (facilite le dÃ©bogage)
        - Avec cell_size=10px : 400Ã—400px (taille raisonnable)

        <strong>Exemple de calcul :</strong>
        Grille 40Ã—40 = 1600 cellules
        Configuration alÃ©atoire Ã  25% = ~400 cellules vivantes
        """
        # 1. Dimensions (attributs privÃ©s)
        self.__width = width
        self.__height = height

        # 2. Compteur de gÃ©nÃ©ration
        self.__generation = 0

        # 3. Structures de donnÃ©es
        self.__grid = []       # Grille 2D de LiveCell
        self.__observers = []  # Liste d'Observer (Pattern Observer)

        # 4. CrÃ©ation de la grille (appel mÃ©thode privÃ©e)
        self.__create_grid()
</pre>

<div class="explication">
<h4>ğŸ’¡ Pourquoi Appeler __create_grid() au Lieu de Tout Faire dans __init__ ?</h4>

<p><strong>Option 1 : Tout dans __init__ (monolithique)</strong></p>
<pre>
def __init__(self, width, height):
    self.__width = width
    self.__height = height
    self.__generation = 0
    self.__grid = []
    self.__observers = []

    # CrÃ©ation de la grille directement (20+ lignes)
    for row in range(self.__height):
        row_cells = []
        for col in range(self.__width):
            row_cells.append(LiveCell(state=False))
        self.__grid.append(row_cells)
    # Plus de code...
</pre>

<p><strong>ProblÃ¨mes :</strong></p>
<ul>
<li>âŒ __init__ devient trÃ¨s long (>50 lignes)</li>
<li>âŒ MÃ©lange de niveaux d'abstraction</li>
<li>âŒ Difficile Ã  tester la crÃ©ation de grille seule</li>
<li>âŒ Pas rÃ©utilisable si on veut recrÃ©er la grille</li>
</ul>

<p><strong>Option 2 : MÃ©thode sÃ©parÃ©e (modulaire) âœ…</strong></p>
<pre>
def __init__(self, width, height):
    self.__width = width
    self.__height = height
    self.__generation = 0
    self.__grid = []
    self.__observers = []
    self.__create_grid()  # DÃ©lÃ©gation

def __create_grid(self):
    # Logique de crÃ©ation isolÃ©e
    for row in range(self.__height):
        row_cells = []
        for col in range(self.__width):
            row_cells.append(LiveCell(state=False))
        self.__grid.append(row_cells)
</pre>

<p><strong>Avantages :</strong></p>
<ul>
<li>âœ… __init__ reste court et clair (vue d'ensemble)</li>
<li>âœ… SÃ©paration des responsabilitÃ©s</li>
<li>âœ… Facile de tester __create_grid() isolÃ©ment</li>
<li>âœ… RÃ©utilisable si on veut recrÃ©er la grille (ex: reset)</li>
<li>âœ… Nom de mÃ©thode explicite : __create_grid() dit ce qu'elle fait</li>
</ul>

<p>
C'est un exemple du principe <strong>Single Responsibility</strong> : chaque mÃ©thode a une responsabilitÃ© unique et bien dÃ©finie.
</p>
</div>

<h3>3.5.4 MÃ©thode Magique __str__</h3>

<pre>
    def __str__(self):
        """
        ReprÃ©sentation textuelle du modÃ¨le (pour dÃ©bogage).

        <strong>MÃ©thode Magique Python :</strong>

        __str__() est une des "mÃ©thodes magiques" (dunder methods)
        de Python. Elle est appelÃ©e automatiquement par :
        - str(obj)
        - print(obj)
        - f"{obj}"

        <strong>DiffÃ©rence avec __repr__() :</strong>

        - __str__() : ReprÃ©sentation "pour les humains" (lisible)
        - __repr__() : ReprÃ©sentation "pour les dÃ©veloppeurs" (debug)

        En gÃ©nÃ©ral :
        - __str__() â†’ Beau, simple
        - __repr__() â†’ Complet, non ambigu, devrait Ãªtre eval()-able

        <strong>Format de sortie :</strong>

        Generation X
        001110000
        000010000
        000111000
        ...

        Chaque "1" = cellule vivante
        Chaque "0" = cellule morte

        <strong>Utilisation typique :</strong>

        >>> model = LiveModel(10, 10)
        >>> model.toggle_cell(5, 5)
        >>> print(model)
        Generation 0
        0000000000
        0000000000
        0000000000
        0000000000
        0000000000
        0000010000
        0000000000
        ...

        <strong>Pourquoi utile ?</strong>

        - DÃ©bogage rapide en console
        - Tests unitaires (vÃ©rifier l'Ã©tat)
        - Logging
        - Pas besoin de l'interface graphique pour voir l'Ã©tat
        """
        # Ligne d'en-tÃªte avec le numÃ©ro de gÃ©nÃ©ration
        result = f"Generation {self.__generation}\n"

        # Parcourir toutes les lignes
        for row in range(self.__height):
            # Parcourir toutes les colonnes de cette ligne
            for col in range(self.__width):
                # Utiliser __str__() de LiveCell (retourne "1" ou "0")
                result += str(self.__grid[row][col])
            # Retour Ã  la ligne aprÃ¨s chaque ligne de la grille
            result += "\n"

        return result
</pre>

<div class="exemple">
<h4>ğŸ“ Exemple Concret d'Utilisation de __str__</h4>

<pre>
<strong>DÃ©bogage en Console :</strong>

>>> model = LiveModel(5, 5)
>>> # CrÃ©er un blinker
>>> model.toggle_cell(2, 1)
>>> model.toggle_cell(2, 2)
>>> model.toggle_cell(2, 3)
>>> print(model)
Generation 0
00000
00000
01110
00000
00000

>>> model.evolve()
>>> print(model)
Generation 1
00000
00100
00100
00100
00000

>>> model.evolve()
>>> print(model)
Generation 2
00000
00000
01110
00000
00000
</pre>

<p>
On voit clairement l'oscillation du blinker sans avoir besoin de l'interface graphique ! C'est trÃ¨s utile pour :
</p>
<ul>
<li>Tests unitaires automatisÃ©s</li>
<li>DÃ©bogage rapide</li>
<li>VÃ©rification des rÃ¨gles</li>
<li>DÃ©monstration en console</li>
</ul>
</div>

<h3>3.5.5 Properties (Accesseurs en Lecture Seule)</h3>

<pre>
    <strong># Properties - AccÃ¨s en lecture seule aux attributs du modÃ¨le</strong>

    @property
    def width(self):
        """
        Largeur de la grille (nombre de cellules).

        <strong>Read-Only Property :</strong>

        Pas de @width.setter â†’ la largeur est IMMUABLE aprÃ¨s crÃ©ation.

        <strong>Pourquoi immuable ?</strong>

        Changer la largeur aprÃ¨s crÃ©ation poserait des problÃ¨mes :
        - La grille a dÃ©jÃ  Ã©tÃ© crÃ©Ã©e avec une certaine taille
        - Il faudrait recrÃ©er toute la grille
        - Les cellules existantes seraient perdues
        - ComplexitÃ© inutile

        <strong>Si on veut vraiment changer la taille :</strong>
        CrÃ©er un nouveau Model avec les nouvelles dimensions.

        Returns:
            int: Largeur en nombre de cellules
        """
        return self.__width

    @property
    def height(self):
        """
        Hauteur de la grille (nombre de cellules).

        Ã‰galement immuable (pas de setter).

        Returns:
            int: Hauteur en nombre de cellules
        """
        return self.__height

    @property
    def generation(self):
        """
        NumÃ©ro de la gÃ©nÃ©ration actuelle.

        <strong>IncrÃ©mentÃ© par evolve() :</strong>
        Commence Ã  0, augmente de 1 Ã  chaque appel de evolve().

        <strong>Remis Ã  0 par clear_grid() :</strong>
        Quand on efface la grille, on remet le compteur Ã  zÃ©ro.

        <strong>UtilisÃ© pour :</strong>
        - Affichage dans la barre de statut
        - Statistiques
        - Sauvegarde/chargement d'Ã©tats
        - DÃ©bogage

        Returns:
            int: NumÃ©ro de gÃ©nÃ©ration (0, 1, 2, ...)
        """
        return self.__generation

    @property
    def grid(self):
        """
        AccÃ¨s Ã  la grille de cellules.

        <strong>âš ï¸ Attention : RÃ©fÃ©rence, pas copie</strong>

        Cette property retourne la RÃ‰FÃ‰RENCE Ã  la grille interne,
        pas une copie. Cela signifie que le code appelant peut
        modifier les cellules directement.

        <strong>Pourquoi ne pas retourner une copie ?</strong>

        >>> grid_copy = [row[:] for row in self.__grid]
        >>> return grid_copy

        Raisons :
        1. Performance : Copier 40Ã—40 cellules Ã  chaque frame = lent
        2. AccÃ¨s nÃ©cessaire : Les stratÃ©gies ont besoin d'un accÃ¨s direct
        3. Confiance : Le Controller lit seulement, ne modifie pas

        <strong>Qui accÃ¨de Ã  cette property ?</strong>

        1. Controller : Pour afficher (lecture seule)
        2. StratÃ©gies : Pour configurer (lecture/Ã©criture)
        3. Tests : Pour vÃ©rifier l'Ã©tat

        <strong>Structure de la grille :</strong>

        grid[row][col] â†’ LiveCell

        Exemple pour 3Ã—3 :
        grid[0][0] grid[0][1] grid[0][2]
        grid[1][0] grid[1][1] grid[1][2]
        grid[2][0] grid[2][1] grid[2][2]

        Returns:
            list: Grille 2D de LiveCell (rÃ©fÃ©rence)
        """
        return self.__grid
</pre>

<div class="important">
<h4>âš ï¸ DÃ©cision de Design : RÃ©fÃ©rence vs Copie</h4>

<p>
Retourner la rÃ©fÃ©rence directe Ã  la grille viole techniquement l'encapsulation, mais c'est une <strong>dÃ©cision consciente</strong> pour des raisons de performance et de praticitÃ©.
</p>

<p><strong>Alternatives considÃ©rÃ©es :</strong></p>

<table>
<tr>
    <th>Option</th>
    <th>Avantages</th>
    <th>InconvÃ©nients</th>
    <th>DÃ©cision</th>
</tr>
<tr>
    <td><strong>RÃ©fÃ©rence directe</strong><br>(notre choix)</td>
    <td>
        âœ… Rapide<br>
        âœ… Pas de copie<br>
        âœ… AccÃ¨s simple
    </td>
    <td>
        âŒ Encapsulation faible<br>
        âŒ Modifications possibles
    </td>
    <td>âœ… Choisi<br>(confiance + perf)</td>
</tr>
<tr>
    <td><strong>Copie profonde</strong></td>
    <td>
        âœ… Encapsulation forte<br>
        âœ… Pas de modification externe
    </td>
    <td>
        âŒ TrÃ¨s lent<br>
        âŒ Copie 1600 objets par frame
    </td>
    <td>âŒ RejetÃ©<br>(trop lent)</td>
</tr>
<tr>
    <td><strong>MÃ©thodes d'accÃ¨s</strong><br>get_cell(row, col)</td>
    <td>
        âœ… ContrÃ´le total<br>
        âœ… Encapsulation parfaite
    </td>
    <td>
        âŒ API verbeuse<br>
        âŒ Beaucoup d'appels
    </td>
    <td>âŒ RejetÃ©<br>(trop verbeux)</td>
</tr>
<tr>
    <td><strong>ItÃ©rateur</strong></td>
    <td>
        âœ… Encapsulation<br>
        âœ… Pattern standard
    </td>
    <td>
        âŒ Pas d'accÃ¨s direct par [row][col]<br>
        âŒ Plus complexe
    </td>
    <td>âŒ RejetÃ©<br>(trop complexe)</td>
</tr>
</table>

<p><strong>Notre compromis :</strong></p>
<p>
On retourne la rÃ©fÃ©rence directe, mais on <strong>documente clairement</strong> que les stratÃ©gies peuvent modifier et que le Controller ne devrait pas. C'est un contrat implicite basÃ© sur la confiance et la discipline d'Ã©quipe.
</p>
</div>

<!-- ================================================================== -->
<!-- Section 3.5.6: Observer Pattern Implementation in LiveModel      -->
<!-- ================================================================== -->

<h3 id="observer-implementation">3.5.6. ImplÃ©mentation du Pattern Observer dans LiveModel</h3>

<div class="concept">
<strong>Rappel :</strong> LiveModel hÃ©rite de Observable et doit donc implÃ©menter les trois mÃ©thodes abstraites : attach(), detach(), et notify_observers().
</div>

<h4>Attribut privÃ© : Liste des observateurs</h4>

<div class="explication">
<strong>Pourquoi une liste d'observateurs ?</strong>
<p>
Le modÃ¨le peut avoir plusieurs observateurs qui veulent Ãªtre notifiÃ©s de ses changements :
</p>
<ul>
    <li>Le Controller principal (pour mettre Ã  jour la vue)</li>
    <li>Un systÃ¨me de statistiques</li>
    <li>Un systÃ¨me de logging</li>
    <li>Un systÃ¨me de sauvegarde automatique</li>
</ul>
<p>
La liste permet de gÃ©rer N observateurs de maniÃ¨re flexible, sans modifier le code du modÃ¨le.
</p>
</div>

<pre><code class="python">
def __init__(self, width=40, height=40):
    # ... autres initialisations ...
    self.__observers = []  # OBSERVER PATTERN: List of observers
</code></pre>

<h4>MÃ©thode attach(observer) : Attacher un observateur</h4>

<pre><code class="python">
def attach(self, observer):
    """
    OBSERVER PATTERN: Attach an observer to this model.

    Args:
        observer (Observer): Observer to be notified of changes
    """
    if observer not in self.__observers:
        self.__observers.append(observer)
</code></pre>

<div class="explication">
<strong>Explication ligne par ligne :</strong>
<ol>
    <li><strong>if observer not in self.__observers:</strong>
        <ul>
            <li>VÃ©rifie que l'observateur n'est pas dÃ©jÃ  dans la liste</li>
            <li>Ã‰vite les doublons (sinon un observateur pourrait Ãªtre notifiÃ© plusieurs fois)</li>
        </ul>
    </li>
    <li><strong>self.__observers.append(observer)</strong>
        <ul>
            <li>Ajoute l'observateur Ã  la liste</li>
            <li>L'observateur recevra maintenant toutes les notifications futures</li>
        </ul>
    </li>
</ol>
</div>

<h4>MÃ©thode detach(observer) : DÃ©tacher un observateur</h4>

<pre><code class="python">
def detach(self, observer):
    """
    OBSERVER PATTERN: Detach an observer from this model.

    Args:
        observer (Observer): Observer to remove
    """
    if observer in self.__observers:
        self.__observers.remove(observer)
</code></pre>

<div class="explication">
<strong>Cas d'usage du detach() :</strong>
<p>
Bien que rarement utilisÃ© dans notre application, detach() est important pour :
</p>
<ul>
    <li><strong>Gestion de la mÃ©moire :</strong> LibÃ©rer les rÃ©fÃ©rences pour permettre la garbage collection</li>
    <li><strong>FenÃªtres multiples :</strong> Si une fenÃªtre se ferme, elle doit se dÃ©tacher du modÃ¨le</li>
    <li><strong>Modes temporaires :</strong> Un systÃ¨me de debug qui s'active/dÃ©sactive</li>
</ul>
</div>

<h4>MÃ©thode notify_observers() : Notifier tous les observateurs</h4>

<pre><code class="python">
def notify_observers(self):
    """
    OBSERVER PATTERN: Notify all observers that the model has changed.

    This is called automatically after state-changing operations.
    """
    for observer in self.__observers:
        observer.update(self)
</code></pre>

<div class="important">
<strong>TRÃˆS IMPORTANT :</strong> Cette mÃ©thode est appelÃ©e AUTOMATIQUEMENT aprÃ¨s CHAQUE modification du modÃ¨le :
<ul>
    <li>AprÃ¨s toggle_cell() â†’ notifie</li>
    <li>AprÃ¨s clear_grid() â†’ notifie</li>
    <li>AprÃ¨s evolve() â†’ notifie</li>
    <li>AprÃ¨s set_random_configuration() â†’ notifie</li>
    <li>AprÃ¨s set_cannon_configuration() â†’ notifie</li>
</ul>
<p>
Cela garantit que la vue est TOUJOURS synchronisÃ©e avec le modÃ¨le.
</p>
</div>

<div class="explication">
<strong>SÃ©quence d'exÃ©cution :</strong>
<ol>
    <li>notify_observers() parcourt la liste __observers</li>
    <li>Pour chaque observateur, elle appelle observer.update(self)</li>
    <li>Le paramÃ¨tre "self" est le modÃ¨le lui-mÃªme</li>
    <li>L'observateur (Controller) peut alors interroger le modÃ¨le (model.grid, model.generation, etc.)</li>
    <li>L'observateur met Ã  jour la vue avec les nouvelles donnÃ©es</li>
</ol>
</div>

<!-- ================================================================== -->
<!-- Section 3.5.7: La mÃ©thode evolve() - Logique centrale du jeu     -->
<!-- ================================================================== -->

<h3 id="evolve-method">3.5.7. La mÃ©thode evolve() : Le cÅ“ur du Game of Life</h3>

<div class="concept">
<strong>evolve() est LA mÃ©thode la plus importante du jeu.</strong>
<p>
Elle implÃ©mente les trois rÃ¨gles de Conway et fait avancer le jeu d'une gÃ©nÃ©ration. C'est ici que la "magie" du Game of Life se produit.
</p>
</div>

<h4>Vue d'ensemble de l'algorithme</h4>

<div class="explication">
<strong>Algorithme en 5 Ã©tapes :</strong>
<ol>
    <li><strong>Compter les voisins</strong> de chaque cellule</li>
    <li><strong>Calculer les nouveaux Ã©tats</strong> selon les rÃ¨gles de Conway</li>
    <li><strong>Stocker temporairement</strong> les nouveaux Ã©tats (ne pas modifier directement !)</li>
    <li><strong>Appliquer tous les nouveaux Ã©tats</strong> en une seule fois</li>
    <li><strong>Mettre Ã  jour les Ã¢ges</strong> des cellules</li>
    <li><strong>IncrÃ©menter la gÃ©nÃ©ration</strong></li>
    <li><strong>Notifier les observateurs</strong></li>
</ol>
</div>

<div class="important">
<strong>PIÃˆGE CLASSIQUE Ã€ Ã‰VITER :</strong>
<p>
âŒ <strong>MAUVAIS :</strong> Modifier les cellules directement pendant le calcul
</p>
<pre><code class="python">
# FAUX - Ne JAMAIS faire Ã§a !
for row in range(height):
    for col in range(width):
        if should_be_alive(row, col):
            grid[row][col].state = True  # âŒ Modification immÃ©diate !
</code></pre>
<p>
<strong>ProblÃ¨me :</strong> Si vous modifiez la cellule (5,5) Ã  True, quand vous comptez les voisins de (5,6), vous comptez le NOUVEAU Ã©tat de (5,5), pas l'ancien ! Les calculs deviennent incorrects.
</p>

<p>
âœ… <strong>CORRECT :</strong> Stocker d'abord tous les nouveaux Ã©tats, PUIS les appliquer
</p>
<pre><code class="python">
# CORRECT - D'abord calculer
new_states = calculate_all_new_states()  # Calcul basÃ© sur l'Ã©tat ACTUEL
# PUIS appliquer
apply_all_states(new_states)  # Application en une seule fois
</code></pre>
<p>
<strong>Solution :</strong> Les nouveaux Ã©tats sont calculÃ©s en se basant sur l'Ã©tat ACTUEL complet de la grille, puis appliquÃ©s tous en mÃªme temps.
</p>
</div>

<h4>Code complet de evolve() avec explications</h4>

<pre><code class="python">
def evolve(self):
    """
    Public method: Evolve to the next generation.

    Game of Life rules:
    - Any live cell with 2-3 neighbors survives
    - Any dead cell with exactly 3 neighbors becomes alive
    - All other cells die or stay dead

    Age tracking:
    - Cell born (dead -> alive): age = 1
    - Cell survives (alive -> alive): age += 1
    - Cell dies (alive -> dead): age = 0
    """
</code></pre>

<h4>Ã‰TAPE 1 : Compter les voisins</h4>

<pre><code class="python">
    # First, count neighbors for all cells
    self.__update_neighbors_count()
</code></pre>

<div class="explication">
<strong>Pourquoi d'abord compter TOUS les voisins ?</strong>
<p>
Cette Ã©tape parcourt TOUTE la grille et met Ã  jour l'attribut neighbors_count de chaque cellule. On le fait AVANT de calculer les nouveaux Ã©tats pour s'assurer que tous les comptages sont basÃ©s sur l'Ã©tat ACTUEL de la grille.
</p>
<p>
La mÃ©thode __update_neighbors_count() est privÃ©e et sera expliquÃ©e plus loin.
</p>
</div>

<h4>Ã‰TAPE 2-3 : Calculer les nouveaux Ã©tats (sans modifier la grille)</h4>

<pre><code class="python">
    # Create new states based on rules
    # Important: Store new states separately to avoid affecting counts
    new_states = []
    for row in range(self.__height):
        row_states = []
        for col in range(self.__width):
            cell = self.__grid[row][col]
            neighbors = cell.neighbors_count
            current_state = cell.state
</code></pre>

<div class="explication">
<strong>Structure de donnÃ©es new_states :</strong>
<p>
new_states est une liste 2D de boolÃ©ens (True/False) qui reprÃ©sente la grille FUTURE. C'est une copie temporaire pour stocker les calculs sans modifier l'original.
</p>
<p>
<strong>Exemple :</strong>
</p>
<pre>
new_states = [
    [False, True, False],   # row 0
    [True, True, True],     # row 1
    [False, False, True]    # row 2
]
</pre>
</div>

<h4>Application des rÃ¨gles de Conway</h4>

<pre><code class="python">
            # Apply Game of Life rules
            if neighbors == 3:
                # Birth: dead cell with 3 neighbors becomes alive
                # Survival: alive cell with 3 neighbors stays alive
                new_state = True
            elif neighbors == 2:
                # Survival: alive cell with 2 neighbors stays alive
                # Death: dead cell with 2 neighbors stays dead
                new_state = current_state
            else:
                # Death: any other case results in death
                new_state = False

            row_states.append(new_state)
        new_states.append(row_states)
</code></pre>

<div class="pattern">
<strong>LES TROIS RÃˆGLES DE CONWAY - Explication dÃ©taillÃ©e :</strong>

<h5>RÃ¨gle 1 : Exactement 3 voisins â†’ Toujours vivante</h5>
<pre><code>if neighbors == 3:
    new_state = True</code></pre>
<ul>
    <li><strong>Si cellule MORTE + 3 voisins :</strong> Naissance (reproduction) âœ¨</li>
    <li><strong>Si cellule VIVANTE + 3 voisins :</strong> Survie (population idÃ©ale) âœ…</li>
</ul>

<h5>RÃ¨gle 2 : Exactement 2 voisins â†’ Ã‰tat inchangÃ©</h5>
<pre><code>elif neighbors == 2:
    new_state = current_state</code></pre>
<ul>
    <li><strong>Si cellule MORTE + 2 voisins :</strong> Reste morte (pas assez pour naÃ®tre) âš«</li>
    <li><strong>Si cellule VIVANTE + 2 voisins :</strong> Survie (population stable) âœ…</li>
</ul>

<h5>RÃ¨gle 3 : Tout autre cas â†’ Morte</h5>
<pre><code>else:
    new_state = False</code></pre>
<ul>
    <li><strong>0-1 voisins :</strong> Solitude â†’ Mort ğŸ’€</li>
    <li><strong>4-8 voisins :</strong> Surpopulation â†’ Mort ğŸ’€</li>
</ul>

<div class="exemple">
<strong>Exemples concrets :</strong>
<table border="1" cellpadding="8">
<tr>
    <th>Ã‰tat actuel</th>
    <th>Voisins</th>
    <th>RÃ¨gle appliquÃ©e</th>
    <th>Nouvel Ã©tat</th>
    <th>Raison</th>
</tr>
<tr>
    <td>Vivante âœ…</td>
    <td>0</td>
    <td>RÃ¨gle 3 (else)</td>
    <td>Morte âš«</td>
    <td>Solitude</td>
</tr>
<tr>
    <td>Vivante âœ…</td>
    <td>1</td>
    <td>RÃ¨gle 3 (else)</td>
    <td>Morte âš«</td>
    <td>Solitude</td>
</tr>
<tr>
    <td>Vivante âœ…</td>
    <td>2</td>
    <td>RÃ¨gle 2 (current_state)</td>
    <td>Vivante âœ…</td>
    <td>Survie</td>
</tr>
<tr>
    <td>Vivante âœ…</td>
    <td>3</td>
    <td>RÃ¨gle 1 (== 3)</td>
    <td>Vivante âœ…</td>
    <td>Survie</td>
</tr>
<tr>
    <td>Vivante âœ…</td>
    <td>4</td>
    <td>RÃ¨gle 3 (else)</td>
    <td>Morte âš«</td>
    <td>Surpopulation</td>
</tr>
<tr>
    <td>Morte âš«</td>
    <td>2</td>
    <td>RÃ¨gle 2 (current_state)</td>
    <td>Morte âš«</td>
    <td>Pas assez pour naÃ®tre</td>
</tr>
<tr>
    <td>Morte âš«</td>
    <td>3</td>
    <td>RÃ¨gle 1 (== 3)</td>
    <td>Vivante âœ…</td>
    <td>Naissance !</td>
</tr>
<tr>
    <td>Morte âš«</td>
    <td>4</td>
    <td>RÃ¨gle 3 (else)</td>
    <td>Morte âš«</td>
    <td>Trop de voisins</td>
</tr>
</table>
</div>
</div>

<h4>Ã‰TAPE 4 : Appliquer les nouveaux Ã©tats et mettre Ã  jour les Ã¢ges</h4>

<pre><code class="python">
    # Apply new states to grid and update ages
    for row in range(self.__height):
        for col in range(self.__width):
            cell = self.__grid[row][col]
            old_state = cell.state
            new_state = new_states[row][col]

            # Update state
            cell.state = new_state
</code></pre>

<div class="explication">
<p>
Maintenant que tous les nouveaux Ã©tats sont calculÃ©s, on peut les appliquer sans risque. On parcourt Ã  nouveau la grille et on met Ã  jour chaque cellule avec son nouvel Ã©tat.
</p>
</div>

<h4>Gestion des Ã¢ges - Nouvelle fonctionnalitÃ© !</h4>

<pre><code class="python">
            # Update age based on state transition
            if new_state:  # Cell is alive
                if old_state:  # Was already alive -> survives
                    cell.age += 1  # Increment age
                else:  # Was dead -> just born
                    cell.age = 1  # Newborn
            else:  # Cell is dead
                cell.age = 0  # Reset age
</code></pre>

<div class="concept">
<strong>Suivi de l'Ã¢ge des cellules (AGE TRACKING)</strong>
<p>
Cette fonctionnalitÃ© permet de savoir depuis combien de gÃ©nÃ©rations une cellule est vivante. C'est utile pour la visualisation par couleurs :
</p>
<ul>
    <li>ğŸ”´ Rouge : Ã‚ge = 1 (nouveau-nÃ©, vient de naÃ®tre)</li>
    <li>ğŸŸ¡ Jaune : Ã‚ge 2-3 (jeune cellule)</li>
    <li>ğŸŸ¢ Vert : Ã‚ge 4-7 (cellule stable)</li>
    <li>ğŸ”µ Bleu : Ã‚ge 8+ (cellule trÃ¨s stable, ancienne)</li>
</ul>
</div>

<div class="explication">
<strong>Logique de mise Ã  jour de l'Ã¢ge (4 cas possibles) :</strong>

<table border="1" cellpadding="8">
<tr>
    <th>Transition</th>
    <th>old_state</th>
    <th>new_state</th>
    <th>Action sur age</th>
    <th>Signification</th>
</tr>
<tr>
    <td>Survie</td>
    <td>True</td>
    <td>True</td>
    <td>age += 1</td>
    <td>La cellule vieillit d'une gÃ©nÃ©ration</td>
</tr>
<tr>
    <td>Naissance</td>
    <td>False</td>
    <td>True</td>
    <td>age = 1</td>
    <td>Nouveau-nÃ© (premiÃ¨re gÃ©nÃ©ration vivante)</td>
</tr>
<tr>
    <td>Mort</td>
    <td>True</td>
    <td>False</td>
    <td>age = 0</td>
    <td>Reset de l'Ã¢ge (cellule morte)</td>
</tr>
<tr>
    <td>Reste morte</td>
    <td>False</td>
    <td>False</td>
    <td>age = 0</td>
    <td>Toujours morte, Ã¢ge reste Ã  0</td>
</tr>
</table>

<p>
<strong>Exemple d'Ã©volution d'une cellule sur 5 gÃ©nÃ©rations :</strong>
</p>
<pre>
Gen 0: Morte (age=0)
Gen 1: Naissance â†’ Vivante (age=1) ğŸ”´ rouge
Gen 2: Survie â†’ Vivante (age=2) ğŸŸ¡ jaune
Gen 3: Survie â†’ Vivante (age=3) ğŸŸ¡ jaune
Gen 4: Survie â†’ Vivante (age=4) ğŸŸ¢ vert
Gen 5: Mort â†’ Morte (age=0) âš« blanc
Gen 6: Morte (age=0) âš« blanc
</pre>
</div>

<h4>Ã‰TAPE 5-6 : IncrÃ©menter la gÃ©nÃ©ration et notifier</h4>

<pre><code class="python">
    # Increment generation counter
    self.__generation += 1

    # OBSERVER PATTERN: Notify observers of state change
    self.notify_observers()
</code></pre>

<div class="explication">
<p>
Enfin, on incrÃ©mente le compteur de gÃ©nÃ©ration (pour l'affichage "Generation: 42") et on notifie tous les observateurs que le modÃ¨le a changÃ©. Le Controller recevra cette notification et mettra Ã  jour l'affichage.
</p>
</div>

<div class="important">
<strong>RÃ©sumÃ© de evolve() :</strong>
<ol>
    <li>âœ… Compte les voisins de toutes les cellules</li>
    <li>âœ… Calcule TOUS les nouveaux Ã©tats (sans modifier la grille)</li>
    <li>âœ… Applique TOUS les nouveaux Ã©tats en une fois</li>
    <li>âœ… Met Ã  jour les Ã¢ges selon les transitions</li>
    <li>âœ… IncrÃ©mente le compteur de gÃ©nÃ©ration</li>
    <li>âœ… Notifie les observateurs</li>
</ol>
<p>
Cette sÃ©paration claire entre "calcul" et "application" est CRUCIALE pour la correction de l'algorithme !
</p>
</div>

<!-- ================================================================== -->
<!-- Section 3.6: MÃ©thodes de configuration                            -->
<!-- ================================================================== -->

<h3 id="configuration-methods">3.6. MÃ©thodes de configuration du LiveModel</h3>

<div class="concept">
<strong>Configuration du jeu :</strong>
<p>
Le modÃ¨le offre plusieurs mÃ©thodes pour initialiser la grille avec diffÃ©rentes configurations de dÃ©part. C'est important car le Game of Life est trÃ¨s sensible aux conditions initiales !
</p>
</div>

<h4>3.6.1. clear_grid() : RÃ©initialiser la grille</h4>

<pre><code class="python">
def clear_grid(self):
    """
    Reset all cells to dead state and reset generation counter.
    """
    for row in range(self.__height):
        for col in range(self.__width):
            cell = self.__grid[row][col]
            cell.state = False
            cell.age = 0  # Reset age
    self.__generation = 0
    self.notify_observers()  # OBSERVER PATTERN: Notify change
</code></pre>

<div class="explication">
<strong>Que fait cette mÃ©thode ?</strong>
<ul>
    <li>Parcourt TOUTES les cellules de la grille</li>
    <li>Met leur Ã©tat Ã  False (morte)</li>
    <li>Reset leur Ã¢ge Ã  0</li>
    <li>Remet le compteur de gÃ©nÃ©ration Ã  0</li>
    <li>Notifie les observateurs (l'affichage se vide)</li>
</ul>
<p>
C'est l'Ã©quivalent du bouton "Clear" dans l'interface : tout est remis Ã  zÃ©ro.
</p>
</div>

<h4>3.6.2. toggle_cell() : Inverser l'Ã©tat d'une cellule</h4>

<pre><code class="python">
def toggle_cell(self, row, col):
    """
    Toggle the state of a cell (alive &lt;-> dead).
    Used for user interaction.

    Args:
        row (int): Row index (0 to height-1)
        col (int): Column index (0 to width-1)
    """
    if 0 <= row < self.__height and 0 <= col < self.__width:
        cell = self.__grid[row][col]
        current_state = cell.state
        cell.state = not current_state
        # Update age: if becoming alive, set age to 1; if dying, set to 0
        cell.age = 1 if cell.state else 0
        self.notify_observers()  # OBSERVER PATTERN: Notify change
</code></pre>

<div class="explication">
<strong>Cas d'usage :</strong>
<p>
Cette mÃ©thode est appelÃ©e quand l'utilisateur CLIQUE sur une cellule dans le canvas. Elle inverse l'Ã©tat :
</p>
<ul>
    <li>Si morte â†’ devient vivante (age = 1)</li>
    <li>Si vivante â†’ devient morte (age = 0)</li>
</ul>
<p>
<strong>VÃ©rification des limites :</strong> Le if vÃ©rifie que row et col sont dans les limites valides (0 Ã  height-1, 0 Ã  width-1). Sans cette vÃ©rification, un clic en dehors de la grille causerait une erreur "index out of range".
</p>
</div>

<h4>3.6.3. set_random_configuration() : Configuration alÃ©atoire</h4>

<pre><code class="python">
def set_random_configuration(self, alive_percentage=0.25):
    """
    Set a random initial configuration.

    Args:
        alive_percentage (float): Percentage of cells to set alive (0.0 to 1.0)
    """
    self.clear_grid()
    for row in range(self.__height):
        for col in range(self.__width):
            if random.random() < alive_percentage:
                cell = self.__grid[row][col]
                cell.state = True
                cell.age = 1  # Newborn cells
    # Note: clear_grid() already called notify_observers()
    # but we call again after adding alive cells
    self.notify_observers()
</code></pre>

<div class="explication">
<strong>Comment Ã§a marche ?</strong>
<ol>
    <li><strong>clear_grid() :</strong> D'abord, on vide la grille complÃ¨tement</li>
    <li><strong>Boucle sur toutes les cellules :</strong> Pour chaque cellule de la grille</li>
    <li><strong>random.random() :</strong> GÃ©nÃ¨re un nombre alÃ©atoire entre 0.0 et 1.0</li>
    <li><strong>Comparaison :</strong> Si ce nombre est &lt; alive_percentage, la cellule devient vivante</li>
</ol>

<p>
<strong>Exemple avec alive_percentage=0.25 (25%) :</strong>
</p>
<ul>
    <li>random.random() gÃ©nÃ¨re 0.18 â†’ 0.18 &lt; 0.25 â†’ âœ… Cellule vivante</li>
    <li>random.random() gÃ©nÃ¨re 0.63 â†’ 0.63 &lt; 0.25 â†’ âŒ Cellule morte</li>
    <li>random.random() gÃ©nÃ¨re 0.12 â†’ 0.12 &lt; 0.25 â†’ âœ… Cellule vivante</li>
    <li>random.random() gÃ©nÃ¨re 0.88 â†’ 0.88 &lt; 0.25 â†’ âŒ Cellule morte</li>
</ul>

<p>
Sur une grille de 40x40 = 1600 cellules, environ 400 cellules seront vivantes (25%).
</p>
</div>

<div class="important">
<strong>Pourquoi 25% ?</strong>
<p>
Le pourcentage de 0.25 (25%) a Ã©tÃ© choisi car c'est un bon Ã©quilibre pour le Game of Life :
</p>
<ul>
    <li>âŒ Trop peu (5-10%) : La population s'Ã©teint rapidement</li>
    <li>âœ… 20-30% : Ã‰quilibre parfait, patterns intÃ©ressants Ã©mergent</li>
    <li>âŒ Trop (50%+) : Surpopulation, tout meurt rapidement</li>
</ul>
</div>

<h4>3.6.4. set_cannon_configuration() : Le Canon Ã  Planeurs de Gosper</h4>

<pre><code class="python">
def set_cannon_configuration(self):
    """
    Set the Gosper Glider Gun configuration.

    Note: Uses direct row/col indices (0, 1, 2...)
          NOT pixel multiplications (0*c, 1*c, 10*c...)
    """
    self.clear_grid()

    # Gosper Glider Gun pattern
    # Pattern coordinates (row, col) - using standard indices
    pattern = [
        # Left square
        (5, 1), (5, 2), (6, 1), (6, 2),
        # Left part
        (5, 11), (6, 11), (7, 11),
        (4, 12), (8, 12),
        (3, 13), (9, 13), (3, 14), (9, 14),
        (6, 15),
        (4, 16), (8, 16),
        (5, 17), (6, 17), (7, 17),
        (6, 18),
        # Right part
        (3, 21), (4, 21), (5, 21),
        (3, 22), (4, 22), (5, 22),
        (2, 23), (6, 23),
        (1, 25), (2, 25), (6, 25), (7, 25),
        # Right square
        (3, 35), (4, 35), (3, 36), (4, 36)
    ]

    for row, col in pattern:
        if 0 <= row < self.__height and 0 <= col < self.__width:
            cell = self.__grid[row][col]
            cell.state = True
            cell.age = 1  # Newborn cells

    # Note: clear_grid() already called notify_observers()
    # but we call again after setting the pattern
    self.notify_observers()
</code></pre>

<div class="concept">
<strong>Qu'est-ce que le Canon Ã  Planeurs de Gosper (Gosper Glider Gun) ?</strong>
<p>
DÃ©couvert en 1970 par Bill Gosper, c'est le PREMIER pattern du Game of Life qui gÃ©nÃ¨re indÃ©finiment d'autres patterns (des planeurs/gliders). C'est une dÃ©couverte historique majeure !
</p>

<div class="exemple">
<strong>CaractÃ©ristiques :</strong>
<ul>
    <li><strong>PÃ©riode :</strong> 30 gÃ©nÃ©rations (revient Ã  l'Ã©tat initial tous les 30 cycles)</li>
    <li><strong>Production :</strong> Ã‰met un nouveau planeur toutes les 30 gÃ©nÃ©rations</li>
    <li><strong>Importance :</strong> A prouvÃ© que le Game of Life peut avoir une croissance illimitÃ©e</li>
    <li><strong>ComplexitÃ© :</strong> 36 cellules vivantes dans le pattern initial</li>
</ul>
</div>
</div>

<div class="explication">
<strong>Structure du code :</strong>
<ol>
    <li><strong>pattern = [...]</strong>
        <ul>
            <li>Liste de tuples (row, col) reprÃ©sentant les coordonnÃ©es des cellules vivantes</li>
            <li>DivisÃ© en 4 parties pour la lisibilitÃ© : left square, left part, right part, right square</li>
            <li>Les commentaires aident Ã  visualiser la structure</li>
        </ul>
    </li>
    <li><strong>for row, col in pattern:</strong>
        <ul>
            <li>Parcourt chaque coordonnÃ©e du pattern</li>
            <li>Unpacking de tuple : (5, 1) â†’ row=5, col=1</li>
        </ul>
    </li>
    <li><strong>if 0 &lt;= row &lt; self.__height and 0 &lt;= col &lt; self.__width:</strong>
        <ul>
            <li>VÃ©rification importante : le pattern peut Ãªtre plus grand que la grille</li>
            <li>On ne place que les cellules qui entrent dans la grille</li>
            <li>Si la grille est trop petite (ex: 20x20), le canon sera tronquÃ©</li>
        </ul>
    </li>
</ol>
</div>

<div class="important">
<strong>Note sur les indices :</strong>
<p>
Remarquez que le pattern utilise des indices DIRECTS (0, 1, 2, 3...) et PAS des multiplications par la taille de cellule (0*c, 1*c, 2*c...). C'est une amÃ©lioration majeure par rapport Ã  la version procÃ©durale !
</p>
<p>
<strong>Pourquoi ?</strong> Parce que le MODÃˆLE ne connaÃ®t pas les pixels. Il travaille avec des indices logiques. C'est la VUE qui convertira ces indices en pixels pour l'affichage.
</p>
</div>

<!-- ================================================================== -->
<!-- Section 3.7: MÃ©thodes privÃ©es du LiveModel                        -->
<!-- ================================================================== -->

<h3 id="private-methods-model">3.7. MÃ©thodes privÃ©es du LiveModel</h3>

<div class="concept">
<strong>MÃ©thodes privÃ©es :</strong>
<p>
Ces mÃ©thodes sont prÃ©fixÃ©es par __ (double underscore) et sont destinÃ©es Ã  un usage INTERNE uniquement. Elles implÃ©mentent les dÃ©tails d'implÃ©mentation que les utilisateurs de la classe n'ont pas besoin de connaÃ®tre.
</p>
</div>

<h4>3.7.1. __create_grid() : CrÃ©ation initiale de la grille</h4>

<pre><code class="python">
def __create_grid(self):
    """
    Private method: Create the initial grid filled with dead cells.
    Uses standard indices (0, 1, 2...) NOT multiplications like 0*c, 1*c
    """
    self.__grid = []
    for row in range(self.__height):
        row_cells = []
        for col in range(self.__width):
            row_cells.append(LiveCell(state=False))
        self.__grid.append(row_cells)
</code></pre>

<div class="explication">
<strong>CrÃ©ation d'une grille 2D en Python :</strong>
<p>
La grille est une <strong>liste de listes</strong> (2D list) :
</p>
<pre>
self.__grid = [
    [Cell, Cell, Cell, Cell],  # row 0
    [Cell, Cell, Cell, Cell],  # row 1
    [Cell, Cell, Cell, Cell],  # row 2
]
</pre>

<p>
<strong>Algorithme :</strong>
</p>
<ol>
    <li>CrÃ©er une liste vide pour la grille</li>
    <li>Pour chaque ligne (row) :
        <ul>
            <li>CrÃ©er une liste vide pour cette ligne</li>
            <li>Pour chaque colonne (col) :
                <ul>
                    <li>CrÃ©er une nouvelle LiveCell(state=False)</li>
                    <li>L'ajouter Ã  la liste de la ligne</li>
                </ul>
            </li>
            <li>Ajouter la ligne complÃ¨te Ã  la grille</li>
        </ul>
    </li>
</ol>
</div>

<div class="important">
<strong>PIÃˆGE CLASSIQUE Python :</strong>
<p>
âŒ <strong>NE JAMAIS FAIRE Ã‡A :</strong>
</p>
<pre><code class="python">
# FAUX - CrÃ©e des RÃ‰FÃ‰RENCES Ã  la mÃªme liste !
row_cells = [LiveCell()] * width
grid = [row_cells] * height  # âŒ Toutes les lignes sont la MÃŠME liste !
</code></pre>
<p>
ProblÃ¨me : Toutes les "lignes" pointent vers le mÃªme objet liste. Modifier grid[0][0] modifie aussi grid[1][0], grid[2][0], etc.
</p>

<p>
âœ… <strong>CORRECT :</strong>
</p>
<pre><code class="python">
# CORRECT - CrÃ©e de NOUVELLES listes et objets
for row in range(height):
    row_cells = []  # Nouvelle liste pour chaque ligne
    for col in range(width):
        row_cells.append(LiveCell())  # Nouvel objet pour chaque cellule
    grid.append(row_cells)
</code></pre>
</div>

<h4>3.7.2. __count_neighbors() : Compter les voisins d'une cellule</h4>

<pre><code class="python">
def __count_neighbors(self, row, col):
    """
    Private method: Count alive neighbors for a cell.

    Note: Uses direct arithmetic, NOT divisions or modulo operations.
    Handles edge cases properly.

    Args:
        row (int): Row index
        col (int): Column index

    Returns:
        int: Number of alive neighbors (0-8)
    """
    count = 0

    # Check all 8 neighboring positions
    for dr in [-1, 0, 1]:
        for dc in [-1, 0, 1]:
            # Skip the cell itself
            if dr == 0 and dc == 0:
                continue

            neighbor_row = row + dr
            neighbor_col = col + dc

            # Check boundaries
            if 0 <= neighbor_row < self.__height and 0 <= neighbor_col < self.__width:
                if self.__grid[neighbor_row][neighbor_col].state:
                    count += 1

    return count
</code></pre>

<div class="concept">
<strong>Les 8 voisins d'une cellule :</strong>
<p>
Dans le Game of Life, chaque cellule a 8 voisins (sauf aux bords) :
</p>
<pre>
    NW   N   NE
      â†–  â†‘  â†—
    W  â† X â†’  E
      â†™  â†“  â†˜
    SW   S   SE
</pre>
<p>
OÃ¹ X est la cellule centrale.
</p>
</div>

<div class="explication">
<strong>Algorithme Ã©lÃ©gant avec dr et dc (delta row, delta column) :</strong>

<table border="1" cellpadding="8">
<tr>
    <th>dr</th>
    <th>dc</th>
    <th>Direction</th>
    <th>Position calculÃ©e</th>
</tr>
<tr><td>-1</td><td>-1</td><td>Nord-Ouest (NW)</td><td>(row-1, col-1)</td></tr>
<tr><td>-1</td><td>0</td><td>Nord (N)</td><td>(row-1, col)</td></tr>
<tr><td>-1</td><td>+1</td><td>Nord-Est (NE)</td><td>(row-1, col+1)</td></tr>
<tr><td>0</td><td>-1</td><td>Ouest (W)</td><td>(row, col-1)</td></tr>
<tr><td>0</td><td>0</td><td><strong>Centre (skip!)</strong></td><td>(row, col)</td></tr>
<tr><td>0</td><td>+1</td><td>Est (E)</td><td>(row, col+1)</td></tr>
<tr><td>+1</td><td>-1</td><td>Sud-Ouest (SW)</td><td>(row+1, col-1)</td></tr>
<tr><td>+1</td><td>0</td><td>Sud (S)</td><td>(row+1, col)</td></tr>
<tr><td>+1</td><td>+1</td><td>Sud-Est (SE)</td><td>(row+1, col+1)</td></tr>
</table>

<p>
<strong>Avantages de cette approche :</strong>
</p>
<ul>
    <li>âœ… <strong>Concis :</strong> 2 boucles imbriquÃ©es au lieu de 8 vÃ©rifications explicites</li>
    <li>âœ… <strong>Ã‰lÃ©gant :</strong> Utilise l'arithmÃ©tique simple (row + dr, col + dc)</li>
    <li>âœ… <strong>GÃ©nÃ©rique :</strong> Facilement extensible (ex: voisinage de Moore vs von Neumann)</li>
</ul>
</div>

<div class="explication">
<strong>Gestion des bords (Edge Handling) :</strong>
<pre><code class="python">
if 0 <= neighbor_row < self.__height and 0 <= neighbor_col < self.__width:
</code></pre>
<p>
<strong>Pourquoi cette vÃ©rification ?</strong>
</p>
<p>
Les cellules sur les bords de la grille n'ont pas 8 voisins. Par exemple, la cellule (0, 0) en haut Ã  gauche n'a que 3 voisins (E, SE, S). Si on essaye d'accÃ©der Ã  grid[-1][0] (Nord), Python va accÃ©der au DERNIER Ã©lÃ©ment (comportement de Python avec les indices nÃ©gatifs), ce qui est INCORRECT !
</p>

<p>
<strong>Exemples :</strong>
</p>
<table border="1" cellpadding="8">
<tr>
    <th>Cellule</th>
    <th>Position</th>
    <th>Voisins valides</th>
    <th>Voisins totaux</th>
</tr>
<tr>
    <td>Coin haut-gauche</td>
    <td>(0, 0)</td>
    <td>E, SE, S</td>
    <td>3 / 8</td>
</tr>
<tr>
    <td>Bord haut</td>
    <td>(0, 20)</td>
    <td>W, E, SW, S, SE</td>
    <td>5 / 8</td>
</tr>
<tr>
    <td>Centre</td>
    <td>(20, 20)</td>
    <td>Tous</td>
    <td>8 / 8</td>
</tr>
</table>
</div>

<div class="important">
<strong>Comparaison avec la version procÃ©durale :</strong>
<p>
La version procÃ©durale utilisait des modulos (%) pour crÃ©er une grille "torique" (bords qui se connectent) :
</p>
<pre><code class="python">
# Version procÃ©durale (TORIQUE)
neighbor_row = (row + dr) % height  # Wraparound
neighbor_col = (col + dc) % width   # Wraparound
</code></pre>
<p>
Notre version POO utilise des <strong>bords fixes</strong> (les cellules aux bords ont moins de voisins). C'est plus simple et plus intuitif pour un utilisateur.
</p>
</div>

<h4>3.7.3. __update_neighbors_count() : Mettre Ã  jour tous les compteurs</h4>

<pre><code class="python">
def __update_neighbors_count(self):
    """
    Private method: Update neighbor count for all cells.
    """
    for row in range(self.__height):
        for col in range(self.__width):
            neighbors = self.__count_neighbors(row, col)
            self.__grid[row][col].neighbors_count = neighbors
</code></pre>

<div class="explication">
<strong>MÃ©thode simple mais cruciale :</strong>
<p>
Cette mÃ©thode parcourt TOUTE la grille et met Ã  jour l'attribut neighbors_count de chaque cellule. Elle est appelÃ©e au DÃ‰BUT de evolve(), avant de calculer les nouveaux Ã©tats.
</p>
<p>
<strong>SÃ©paration des responsabilitÃ©s :</strong>
</p>
<ul>
    <li>__count_neighbors(row, col) : Compte les voisins d'UNE cellule</li>
    <li>__update_neighbors_count() : Applique __count_neighbors() Ã  TOUTES les cellules</li>
</ul>
<p>
Cette sÃ©paration rend le code plus modulaire et testable.
</p>
</div>

<!-- ================================================================== -->
<!-- CHAPITRE 4: LIVEVIEW.PY - LA COUCHE VUE (VIEW)                   -->
<!-- ================================================================== -->

<h2 id="chapter-liveview">4. LIVEVIEW.PY - La couche Vue (VIEW)</h2>

<div class="concept">
<strong>La Vue dans MVC :</strong>
<p>
La Vue est responsable de TOUTE la prÃ©sentation visuelle. Elle ne contient AUCUNE logique mÃ©tier. Son rÃ´le est de :
</p>
<ul>
    <li>Afficher les donnÃ©es que le Controller lui fournit</li>
    <li>Capturer les Ã©vÃ©nements utilisateur (clics, touches)</li>
    <li>Transmettre ces Ã©vÃ©nements au Controller</li>
</ul>
<p>
<strong>RÃ¨gle d'or :</strong> La Vue ne connaÃ®t PAS le ModÃ¨le. Elle ne fait qu'afficher ce que le Controller lui dit d'afficher.
</p>
</div>

<div class="important">
<strong>SÃ©paration cruciale : INDICES vs PIXELS</strong>
<p>
Le ModÃ¨le travaille avec des <strong>indices</strong> (0, 1, 2, 3...) tandis que la Vue travaille avec des <strong>pixels</strong> (0, 10, 20, 30...).
</p>
<p>
Cette sÃ©paration est ESSENTIELLE pour la flexibilitÃ© :
</p>
<ul>
    <li>Changer la taille des cellules (cell_size) ne modifie PAS le modÃ¨le</li>
    <li>La mÃªme grille 40x40 peut Ãªtre affichÃ©e en 400x400 pixels OU 800x800 pixels</li>
    <li>Le modÃ¨le reste indÃ©pendant de la reprÃ©sentation visuelle</li>
</ul>
</div>

<!-- ================================================================== -->
<!-- Section 4.1: LiveCanvas - Le canvas de dessin                     -->
<!-- ================================================================== -->

<h3 id="livecanvas">4.1. LiveCanvas : Le canvas de dessin</h3>

<div class="concept">
<strong>ResponsabilitÃ© de LiveCanvas :</strong>
<p>
LiveCanvas encapsule le widget Canvas de Tkinter et s'occupe de dessiner la grille et les cellules. C'est la surface de dessin principale de l'application.
</p>
</div>

<h4>4.1.1. Initialisation du Canvas</h4>

<pre><code class="python">
class LiveCanvas:
    def __init__(self, parent, width, height, cell_size=10):
        """
        Initialize the canvas.

        Args:
            parent: Parent tkinter widget
            width (int): Number of cells horizontally
            height (int): Number of cells vertically
            cell_size (int): Size of each cell in pixels
        """
        self.__width = width
        self.__height = height
        self.__cell_size = cell_size

        # Calculate canvas dimensions in pixels
        canvas_width = width * cell_size
        canvas_height = height * cell_size

        # Create canvas widget
        self.__canvas = Canvas(
            parent,
            width=canvas_width,
            height=canvas_height,
            bg='white'
        )
        self.__canvas.pack(side=TOP, padx=5, pady=5)
</code></pre>

<div class="explication">
<strong>Conversion indices â†’ pixels :</strong>
<p>
Notez le calcul important :
</p>
<pre>
canvas_width = width * cell_size
canvas_height = height * cell_size
</pre>
<p>
<strong>Exemple :</strong> Si width=40 et cell_size=10, alors canvas_width=400 pixels.
</p>
<p>
Cette conversion se fait UNE SEULE FOIS Ã  l'initialisation. Le canvas a une taille FIXE en pixels, mais reprÃ©sente une grille logique de width x height cellules.
</p>
</div>

<h4>4.1.2. SystÃ¨me de couleurs basÃ© sur l'Ã‚GE</h4>

<pre><code class="python">
        # Color configuration
        self.__colors = {
            'alive': 'black',
            'dead': 'white',
            'grid': 'gray',
            # Colors based on cell age (generations alive)
            'newborn': '#FF4444',      # Red - just born (age = 1)
            'young': '#FFDD44',        # Yellow - young (age 2-3)
            'stable': '#44DD44',       # Green - stable (age 4-7)
            'old': '#4444FF'           # Blue - old/very stable (age >= 8)
        }
</code></pre>

<div class="concept">
<strong>Palette de couleurs intelligente :</strong>
<p>
Les couleurs reprÃ©sentent la STABILITÃ‰ des cellules, pas leur Ã©tat simplement binaire vivant/mort. Cela permet de visualiser la dynamique du jeu :
</p>
<ul>
    <li>ğŸ”´ <strong>Rouge (#FF4444) :</strong> Nouveau-nÃ©, Ã¢ge = 1. Ces cellules viennent juste de naÃ®tre.</li>
    <li>ğŸŸ¡ <strong>Jaune (#FFDD44) :</strong> Jeune, Ã¢ge 2-3. Cellules rÃ©centes mais qui ont survÃ©cu quelques gÃ©nÃ©rations.</li>
    <li>ğŸŸ¢ <strong>Vert (#44DD44) :</strong> Stable, Ã¢ge 4-7. Cellules bien Ã©tablies dans des structures stables.</li>
    <li>ğŸ”µ <strong>Bleu (#4444FF) :</strong> TrÃ¨s stable, Ã¢ge 8+. Cellules anciennes, parties de structures trÃ¨s stables (blocs, ruches, etc.).</li>
</ul>
</div>

<div class="exemple">
<strong>Exemple visuel avec le Canon de Gosper :</strong>
<p>
Quand le Canon Ã  Planeurs fonctionne :
</p>
<ul>
    <li>Le <strong>canon lui-mÃªme</strong> (structure oscillante) aura des cellules ğŸ”µ bleues (trÃ¨s stables, reviennent rÃ©guliÃ¨rement)</li>
    <li>Les <strong>planeurs Ã©mis</strong> auront d'abord des cellules ğŸ”´ rouges (nouvelles), puis ğŸŸ¡ jaunes et ğŸŸ¢ vertes en se dÃ©plaÃ§ant</li>
    <li>Les zones de <strong>turbulence</strong> auront beaucoup de ğŸ”´ rouge (naissances/morts rapides)</li>
</ul>
<p>
Cette visualisation aide Ã  COMPRENDRE la dynamique du jeu !
</p>
</div>

<h4>4.1.3. MÃ©thode draw_cell() : Dessiner UNE cellule</h4>

<pre><code class="python">
def draw_cell(self, row, col, state, age=0):
    """
    Draw a single cell.

    FEATURE: Colors vary based on cell age (generations alive).

    Args:
        row (int): Model row index
        col (int): Model column index
        state (bool): True if alive, False if dead
        age (int): Cell age in generations (for color variation)
    """
    x1, y1, x2, y2 = self.__model_to_canvas(row, col)

    # Determine color based on state and age
    if state:
        # Cell is alive - color varies by age
        if age == 1:
            # Newborn (just born)
            fill_color = self.__colors['newborn']  # Red
        elif age <= 3:
            # Young (2-3 generations)
            fill_color = self.__colors['young']  # Yellow
        elif age <= 7:
            # Stable (4-7 generations)
            fill_color = self.__colors['stable']  # Green
        else:
            # Old/very stable (8+ generations)
            fill_color = self.__colors['old']  # Blue
    else:
        # Cell is dead
        fill_color = self.__colors['dead']  # White

    self.__canvas.create_rectangle(
        x1, y1, x2, y2,
        fill=fill_color,
        outline=''  # No outline for cells (grid lines handle that)
    )
</code></pre>

<div class="explication">
<strong>Logique de sÃ©lection de couleur :</strong>
<p>
La structure if/elif/else est organisÃ©e par <strong>Ã¢ge croissant</strong> :
</p>
<ol>
    <li><strong>age == 1 :</strong> Exactement 1 â†’ Rouge (nouveau-nÃ©)</li>
    <li><strong>age <= 3 :</strong> 2 ou 3 â†’ Jaune (jeune)</li>
    <li><strong>age <= 7 :</strong> 4, 5, 6 ou 7 â†’ Vert (stable)</li>
    <li><strong>else :</strong> 8 ou plus â†’ Bleu (trÃ¨s stable)</li>
</ol>
<p>
Les seuils (1, 3, 7) ont Ã©tÃ© choisis pour Ã©quilibrer la rÃ©partition des couleurs et rendre les patterns visuellement intÃ©ressants.
</p>
</div>

<div class="important">
<strong>Conversion indices â†’ pixels :</strong>
<p>
La ligne la plus importante est :
</p>
<pre><code class="python">
x1, y1, x2, y2 = self.__model_to_canvas(row, col)
</code></pre>
<p>
Cette mÃ©thode privÃ©e convertit les indices du modÃ¨le (row, col) en coordonnÃ©es pixels (x1, y1, x2, y2) pour le rectangle Ã  dessiner. C'est LE SEUL endroit oÃ¹ cette conversion se fait pour le dessin.
</p>
</div>

<h4>4.1.4. MÃ©thodes de conversion : Le pont entre ModÃ¨le et Vue</h4>

<h5>__model_to_canvas() : Indices â†’ Pixels</h5>

<pre><code class="python">
def __model_to_canvas(self, row, col):
    """
    Private method: Convert model indices to canvas pixel coordinates.

    Important: This is the ONLY place where we convert indices to pixels.
    Uses direct multiplication, NOT divisions or modulo.

    Args:
        row (int): Model row index (0, 1, 2...)
        col (int): Model column index (0, 1, 2...)

    Returns:
        tuple: (x1, y1, x2, y2) rectangle coordinates in pixels
    """
    x1 = col * self.__cell_size
    y1 = row * self.__cell_size
    x2 = x1 + self.__cell_size
    y2 = y1 + self.__cell_size
    return (x1, y1, x2, y2)
</code></pre>

<div class="explication">
<strong>Calcul gÃ©omÃ©trique :</strong>
<p>
Pour dessiner un rectangle reprÃ©sentant la cellule (row=5, col=3) avec cell_size=10 :
</p>
<pre>
x1 = 3 * 10 = 30      (coin supÃ©rieur gauche, x)
y1 = 5 * 10 = 50      (coin supÃ©rieur gauche, y)
x2 = 30 + 10 = 40     (coin infÃ©rieur droit, x)
y2 = 50 + 10 = 60     (coin infÃ©rieur droit, y)

Rectangle dessinÃ© de (30, 50) Ã  (40, 60)
</pre>
<p>
<strong>Important :</strong> Notez que col dÃ©termine x (horizontal) et row dÃ©termine y (vertical). C'est la convention standard des matrices.
</p>
</div>

<div class="exemple">
<strong>Visualisation :</strong>
<pre>
Grille logique (indices):        Canvas (pixels, cell_size=10):
  0   1   2   3                    0   10  20  30  40
0 â¬œ  â¬œ  â¬œ  â¬œ               0   â”Œâ”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”
1 â¬œ  â¬œ  â¬œ  â¬œ              10   â”œâ”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¤
2 â¬œ  â¬œ  â¬œ  â¬œ              20   â”œâ”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¤
3 â¬œ  â¬œ  â¬œ  â¬œ              30   â”œâ”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¤
4 â¬œ  â¬œ  â¬œ  â¬œ              40   â”œâ”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¤
5 â¬œ  â¬œ  â¬œ  ğŸŸ¢ (5,3)       50   â”œâ”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼ğŸŸ¢â”€â”¤
                            60   â””â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”˜
</pre>
<p>
La cellule logique (5, 3) devient le rectangle pixels (30, 50, 40, 60).
</p>
</div>

<h5>__canvas_to_model() : Pixels â†’ Indices</h5>

<pre><code class="python">
def __canvas_to_model(self, x, y):
    """
    Private method: Convert canvas pixel coordinates to model indices.

    Important: Uses integer division (//) NOT modulo (%)
    This is cleaner than the procedural version's event.x % c

    Args:
        x (int): Canvas x coordinate in pixels
        y (int): Canvas y coordinate in pixels

    Returns:
        tuple: (row, col) model indices
    """
    col = x // self.__cell_size
    row = y // self.__cell_size
    return (row, col)
</code></pre>

<div class="explication">
<strong>Division entiÃ¨re (//) :</strong>
<p>
L'opÃ©rateur // fait une division entiÃ¨re (arrondie vers le bas) :
</p>
<pre>
x = 37 pixels, cell_size = 10
col = 37 // 10 = 3   (pas 3.7, mais 3 !)

y = 52 pixels, cell_size = 10
row = 52 // 10 = 5
</pre>
<p>
Un clic Ã  (37, 52) pixels correspond donc Ã  la cellule (row=5, col=3).
</p>
</div>

<div class="important">
<strong>AmÃ©lioration par rapport Ã  la version procÃ©durale :</strong>
<p>
La version procÃ©durale utilisait INCORRECTEMENT le modulo (%) :
</p>
<pre><code class="python">
# Version procÃ©durale (INCORRECT pour la conversion !)
col = event.x % cell_size  # âŒ Donne le RESTE, pas l'indice !
</code></pre>
<p>
Notre version OOP utilise correctement la division entiÃ¨re (//) :
</p>
<pre><code class="python">
# Version OOP (CORRECT)
col = x // cell_size  # âœ… Donne l'indice correct
</code></pre>
</div>

<h4>4.1.5. display_grid() : Afficher toute la grille</h4>

<pre><code class="python">
def display_grid(self, grid):
    """
    Display the entire grid from model.

    This is the main display method called by controller.
    Separates visualization from game logic.

    ITERATOR PATTERN: Uses __grid_iterator() instead of nested loops.

    Args:
        grid: 2D list of LiveCell objects from model
    """
    # Clear previous display
    self.clear()

    # Draw all cells FIRST using ITERATOR PATTERN
    for row, col, cell in self.__grid_iterator(grid):
        self.draw_cell(row, col, cell.state, cell.age)

    # Draw grid lines AFTER cells (so they appear on top)
    self.draw_grid()
</code></pre>

<div class="pattern">
<strong>ITERATOR PATTERN :</strong>
<p>
Au lieu d'utiliser des boucles for imbriquÃ©es classiques, nous utilisons un itÃ©rateur personnalisÃ© __grid_iterator() qui gÃ©nÃ¨re des tuples (row, col, cell).
</p>

<p>
<strong>Avantages :</strong>
</p>
<ul>
    <li>âœ… Code plus lisible : une seule boucle au lieu de deux imbriquÃ©es</li>
    <li>âœ… Encapsulation : la logique de parcours est cachÃ©e dans l'itÃ©rateur</li>
    <li>âœ… FlexibilitÃ© : on peut changer l'ordre de parcours sans modifier display_grid()</li>
    <li>âœ… Efficace : utilise un gÃ©nÃ©rateur (yield) qui ne consomme pas de mÃ©moire</li>
</ul>
</div>

<h5>__grid_iterator() : GÃ©nÃ©rateur Python</h5>

<pre><code class="python">
def __grid_iterator(self, grid):
    """
    ITERATOR PATTERN: Generator that yields all cells with their coordinates.

    This is a private iterator method that implements the Iterator Pattern
    to traverse the grid in a clean, memory-efficient way.

    Args:
        grid: 2D list of LiveCell objects

    Yields:
        tuple: (row, col, cell) for each cell in the grid
    """
    for row in range(len(grid)):
        for col in range(len(grid[row])):
            yield (row, col, grid[row][col])
</code></pre>

<div class="concept">
<strong>GÃ©nÃ©rateurs Python (yield) :</strong>
<p>
Un gÃ©nÃ©rateur est une fonction qui utilise <strong>yield</strong> au lieu de <strong>return</strong>. Elle produit des valeurs une par une, Ã  la demande, sans crÃ©er de liste complÃ¨te en mÃ©moire.
</p>

<p>
<strong>Comparaison :</strong>
</p>
<pre><code class="python">
# Version avec liste (consomme mÃ©moire)
def get_all_cells(grid):
    result = []
    for row in range(len(grid)):
        for col in range(len(grid[row])):
            result.append((row, col, grid[row][col]))
    return result  # Retourne TOUTE la liste

# Version avec gÃ©nÃ©rateur (efficace)
def grid_iterator(grid):
    for row in range(len(grid)):
        for col in range(len(grid[row])):
            yield (row, col, grid[row][col])  # GÃ©nÃ¨re une valeur Ã  la fois
</code></pre>
</div>

<div class="explication">
<strong>Ordre de dessin important :</strong>
<ol>
    <li><strong>clear() :</strong> Efface tout le canvas</li>
    <li><strong>Dessiner les cellules :</strong> Parcourt toutes les cellules et les dessine (rectangles colorÃ©s)</li>
    <li><strong>draw_grid() :</strong> Dessine les lignes de grille PAR-DESSUS les cellules</li>
</ol>
<p>
<strong>Pourquoi cet ordre ?</strong> Si on dessine la grille AVANT les cellules, les rectangles colorÃ©s vont recouvrir les lignes de grille. En dessinant la grille APRÃˆS, les lignes apparaissent clairement par-dessus les cellules.
</p>
</div>

<!-- ================================================================== -->
<!-- Section 4.2: LiveCommandBar - Barre de boutons                   -->
<!-- ================================================================== -->

<h3 id="livecommandbar">4.2. LiveCommandBar : La barre de commandes</h3>

<div class="concept">
<strong>ResponsabilitÃ© de LiveCommandBar :</strong>
<p>
Cette classe encapsule la barre de boutons de contrÃ´le. Elle crÃ©e et gÃ¨re les widgets de contrÃ´le (boutons, champs de saisie) mais ne contient AUCUNE logique mÃ©tier.
</p>
</div>

<h4>4.2.1. CrÃ©ation de boutons</h4>

<pre><code class="python">
def create_button(self, text, command):
    """
    Create a button and add it to the command bar.

    Args:
        text (str): Button label
        command: Function to call when clicked

    Returns:
        Button: The created button widget
    """
    button = Button(self.__frame, text=text, command=command)
    button.pack(side=LEFT, padx=3, pady=3)
    self.__buttons[text] = button
    return button
</code></pre>

<div class="explication">
<strong>Pattern de crÃ©ation de widgets :</strong>
<p>
Cette mÃ©thode suit un pattern classique :
</p>
<ol>
    <li><strong>CrÃ©er le widget :</strong> Button(...)</li>
    <li><strong>Le positionner :</strong> pack(side=LEFT) â†’ les boutons s'alignent horizontalement</li>
    <li><strong>Le sauvegarder :</strong> self.__buttons[text] = button â†’ pour pouvoir y accÃ©der plus tard</li>
    <li><strong>Le retourner :</strong> return button â†’ au cas oÃ¹ l'appelant en a besoin</li>
</ol>
</div>

<div class="exemple">
<strong>Utilisation dans le Controller :</strong>
<pre><code class="python">
command_bar.create_button("Start", self.on_start_stop)
command_bar.create_button("Step", self.on_step)
command_bar.create_button("Clear", self.on_clear)
command_bar.create_button("Random", self.on_random)
command_bar.create_button("Cannon", self.on_cannon)
</code></pre>
<p>
Chaque bouton est associÃ© Ã  une mÃ©thode du Controller qui sera appelÃ©e au clic.
</p>
</div>

<h4>4.2.2. get_button() : AccÃ©der Ã  un bouton crÃ©Ã©</h4>

<pre><code class="python">
def get_button(self, text):
    """
    Get a button by its text.

    Args:
        text (str): Button label

    Returns:
        Button: The button widget or None
    """
    return self.__buttons.get(text)
</code></pre>

<div class="pourquoi">
<strong>Pourquoi cette mÃ©thode ?</strong>
<p>
Le Controller a besoin d'accÃ©der au bouton "Start" pour changer son texte entre "Start" et "Stop" pendant l'animation :
</p>
<pre><code class="python">
button = self.__view.command_bar.get_button("Start")
if button:
    button.config(text="Stop")  # Change le texte du bouton
</code></pre>
<p>
Sans get_button(), le Controller n'aurait aucun moyen d'accÃ©der au bouton aprÃ¨s sa crÃ©ation.
</p>
</div>

<!-- ================================================================== -->
<!-- Section 4.3: LiveView - Vue principale                            -->
<!-- ================================================================== -->

<h3 id="liveview-main">4.3. LiveView : La vue principale</h3>

<div class="concept">
<strong>LiveView est la faÃ§ade de la couche View :</strong>
<p>
C'est la classe principale qui assemble tous les composants visuels. Elle utilise la COMPOSITION pour intÃ©grer LiveCanvas et LiveCommandBar.
</p>
</div>

<h4>4.3.1. Initialisation de la fenÃªtre</h4>

<pre><code class="python">
def __init__(self, title="Game of Life"):
    """
    Initialize the main view.

    Args:
        title (str): Window title
    """
    self.__title = title
    self.__root = Tk()
    self.__root.title(self.__title)

    # Components will be created by public methods
    self.__canvas = None
    self.__command_bar = None
    self.__status_label = None
</code></pre>

<div class="explication">
<strong>Initialisation en deux temps :</strong>
<p>
Remarquez que les composants (canvas, command_bar, status_label) sont initialisÃ©s Ã  None. Ils seront crÃ©Ã©s PLUS TARD par le Controller via les mÃ©thodes create_canvas(), create_command_bar(), etc.
</p>
<p>
<strong>Pourquoi ?</strong> Cela donne au Controller le contrÃ´le sur QUAND et COMMENT crÃ©er les composants. Il peut spÃ©cifier les dimensions, passer des callbacks, etc.
</p>
</div>

<h4>4.3.2. Properties pour accÃ©der aux composants</h4>

<pre><code class="python">
@property
def root(self):
    """Get the root window"""
    return self.__root

@property
def canvas(self):
    """Get the canvas component"""
    return self.__canvas

@property
def command_bar(self):
    """Get the command bar component"""
    return self.__command_bar
</code></pre>

<div class="explication">
<strong>AccÃ¨s en lecture seule :</strong>
<p>
Ces properties permettent au Controller d'accÃ©der aux composants sans les modifier directement. Le Controller peut faire :
</p>
<pre><code class="python">
self.__view.canvas.display_grid(grid)  # âœ… OK
self.__view.canvas.bind_click(callback)  # âœ… OK
</code></pre>
<p>
Mais ne peut pas remplacer le canvas :
</p>
<pre><code class="python">
self.__view.canvas = autre_canvas  # âŒ Erreur (pas de setter)
</code></pre>
</div>

<h4>4.3.3. MÃ©thodes de crÃ©ation de composants</h4>

<pre><code class="python">
def create_canvas(self, width, height, cell_size=10):
    """
    Create the canvas component.

    Args:
        width (int): Number of cells horizontally
        height (int): Number of cells vertically
        cell_size (int): Cell size in pixels

    Returns:
        LiveCanvas: The created canvas
    """
    self.__canvas = LiveCanvas(self.__root, width, height, cell_size)
    return self.__canvas

def create_command_bar(self):
    """
    Create the command bar component.

    Returns:
        LiveCommandBar: The created command bar
    """
    self.__command_bar = LiveCommandBar(self.__root)
    return self.__command_bar

def create_status_bar(self):
    """
    Create a status label at the bottom.

    Returns:
        Label: The status label
    """
    self.__status_label = Label(
        self.__root,
        text="Generation: 0 | Status: Ready",
        relief=SUNKEN,
        anchor=W
    )
    self.__status_label.pack(side=BOTTOM, fill=X)
    return self.__status_label
</code></pre>

<div class="explication">
<strong>Pattern "Factory Methods" :</strong>
<p>
Ces mÃ©thodes sont des "factory methods" qui crÃ©ent et retournent des composants. Elles permettent au Controller de construire l'interface progressivement :
</p>
<pre><code class="python">
# Dans le Controller
canvas = self.__view.create_canvas(width=40, height=40, cell_size=10)
command_bar = self.__view.create_command_bar()
status_bar = self.__view.create_status_bar()
</code></pre>
</div>

<h4>4.3.4. update_status() : Mettre Ã  jour la barre d'Ã©tat</h4>

<pre><code class="python">
def update_status(self, generation, status="Running"):
    """
    Update the status display.

    Args:
        generation (int): Current generation number
        status (str): Current status text
    """
    if self.__status_label:
        self.__status_label.config(
            text=f"Generation: {generation} | Status: {status}"
        )
</code></pre>

<div class="explication">
<strong>f-string formatting :</strong>
<p>
La f-string (f"...{variable}...") est une fonctionnalitÃ© Python moderne pour formater des chaÃ®nes :
</p>
<pre><code class="python">
generation = 42
status = "Running | Population: 156"
text = f"Generation: {generation} | Status: {status}"
# RÃ©sultat: "Generation: 42 | Status: Running | Population: 156"
</code></pre>
</div>

<!-- ================================================================== -->
<!-- CHAPITRE 5: LIVECONTROLLER.PY - LE CONTRÃ”LEUR                    -->
<!-- ================================================================== -->

<h2 id="chapter-livecontroller">5. LIVECONTROLLER.PY - Le ContrÃ´leur (CONTROLLER)</h2>

<div class="concept">
<strong>Le ContrÃ´leur dans MVC :</strong>
<p>
Le Controller est le CHEF D'ORCHESTRE. Il :
</p>
<ul>
    <li>DÃ©tient des rÃ©fÃ©rences au ModÃ¨le et Ã  la Vue</li>
    <li>Capture les Ã©vÃ©nements utilisateur depuis la Vue</li>
    <li>Appelle les mÃ©thodes appropriÃ©es du ModÃ¨le</li>
    <li>Met Ã  jour la Vue avec les nouvelles donnÃ©es du ModÃ¨le</li>
    <li>GÃ¨re la boucle d'animation</li>
</ul>
<p>
<strong>RÃ¨gle d'or :</strong> Le Controller est le SEUL Ã  connaÃ®tre Ã  la fois le ModÃ¨le ET la Vue. Il fait le lien entre les deux.
</p>
</div>

<h3 id="controller-init">5.1. Initialisation du Controller</h3>

<pre><code class="python">
class LiveController(Observer):
    """
    Main controller for Game of Life.

    Responsibilities:
    - Coordinate Model and View
    - Handle all user events (buttons, clicks)
    - Manage animation loop
    - Update display based on model state

    Following MVC pattern: Controller is the mediator
    """

    def __init__(self, model, view):
        """
        Initialize the controller.

        Args:
            model (LiveModel): The game model
            view (LiveView): The game view
        """
        self.__model = model
        self.__view = view
        self.__counter = LiveCounter()  # Statistics tracker

        # OBSERVER PATTERN: Register this controller as an observer of the model
        self.__model.attach(self)

        # Animation state
        self.__is_running = False
        self.__animation_speed = 100  # milliseconds between generations

        # Setup the view components
        self.__setup_view()

        # Connect events
        self.__connect_events()

        # Initial display
        self.__update_display()
</code></pre>

<div class="important">
<strong>OBSERVER PATTERN - Enregistrement :</strong>
<pre><code class="python">
self.__model.attach(self)
</code></pre>
<p>
Cette ligne est CRUCIALE ! Elle enregistre le Controller comme observateur du ModÃ¨le. DÃ©sormais, chaque fois que le ModÃ¨le change (via notify_observers()), le Controller sera notifiÃ© automatiquement via sa mÃ©thode update().
</p>
</div>

<div class="explication">
<strong>Ordre d'initialisation important :</strong>
<ol>
    <li><strong>Sauvegarder les rÃ©fÃ©rences :</strong> model, view, counter</li>
    <li><strong>S'attacher comme observateur :</strong> model.attach(self)</li>
    <li><strong>Initialiser l'Ã©tat d'animation :</strong> is_running, animation_speed</li>
    <li><strong>Configurer la vue :</strong> __setup_view() crÃ©e les widgets</li>
    <li><strong>Connecter les Ã©vÃ©nements :</strong> __connect_events() lie les callbacks</li>
    <li><strong>Affichage initial :</strong> __update_display() affiche l'Ã©tat initial</li>
</ol>
<p>
Cet ordre est important car chaque Ã©tape dÃ©pend des prÃ©cÃ©dentes.
</p>
</div>

<h3 id="controller-observer">5.2. ImplÃ©mentation du Pattern Observer</h3>

<pre><code class="python">
def update(self, subject):
    """
    OBSERVER PATTERN: Called when the observed Model changes state.

    This method is required by the Observer interface.
    It's called automatically by the Model when state changes.

    Args:
        subject: The object that changed (LiveModel)
    """
    # Update the display to reflect the new model state
    self.__update_display()
</code></pre>

<div class="concept">
<strong>Le flux Observer complet :</strong>
<ol>
    <li><strong>Utilisateur clique "Step"</strong> â†’ Controller.on_step() est appelÃ©</li>
    <li><strong>Controller appelle Model :</strong> model.evolve()</li>
    <li><strong>Model se modifie</strong> et appelle notify_observers()</li>
    <li><strong>Model notifie le Controller :</strong> controller.update(self)</li>
    <li><strong>Controller met Ã  jour la Vue :</strong> __update_display()</li>
    <li><strong>Vue redessine :</strong> canvas.display_grid(grid)</li>
    <li><strong>Utilisateur voit</strong> la nouvelle gÃ©nÃ©ration !</li>
</ol>
</div>

<div class="important">
<strong>Avantage du Pattern Observer :</strong>
<p>
Le ModÃ¨le n'a PAS besoin de connaÃ®tre le Controller ! Il appelle simplement notify_observers() et tous les observateurs enregistrÃ©s sont automatiquement notifiÃ©s.
</p>
<p>
Cela permet d'avoir PLUSIEURS observateurs (ex: un Controller pour l'affichage, un Logger pour les logs, un Saver pour la sauvegarde automatique) sans modifier le ModÃ¨le !
</p>
</div>

<h3 id="controller-events">5.3. Gestionnaires d'Ã©vÃ©nements (Event Handlers)</h3>

<h4>5.3.1. on_start_stop() : DÃ©marrer/ArrÃªter l'animation</h4>

<pre><code class="python">
def on_start_stop(self):
    """
    Handle Start/Stop button click.
    Toggle animation state.
    """
    self.__is_running = not self.__is_running

    if self.__is_running:
        # Start animation
        button = self.__view.command_bar.get_button("Start")
        if button:
            button.config(text="Stop")
        self.__animate()
    else:
        # Stop animation
        button = self.__view.command_bar.get_button("Start")
        if button:
            button.config(text="Start")
        self.__update_display()
</code></pre>

<div class="explication">
<strong>Toggle (basculement) :</strong>
<pre><code class="python">
self.__is_running = not self.__is_running
</code></pre>
<p>
Cette ligne inverse l'Ã©tat boolÃ©en : si True devient False, si False devient True. C'est le pattern classique pour un bouton "toggle".
</p>

<p>
<strong>Changement du texte du bouton :</strong>
</p>
<ul>
    <li>Si on dÃ©marre (is_running = True) â†’ Changer le texte en "Stop"</li>
    <li>Si on arrÃªte (is_running = False) â†’ Changer le texte en "Start"</li>
</ul>
<p>
Cela donne un feedback visuel clair Ã  l'utilisateur sur l'Ã©tat actuel.
</p>
</div>

<h4>5.3.2. on_step() : Avancer d'une gÃ©nÃ©ration</h4>

<pre><code class="python">
def on_step(self):
    """
    Handle Step button click.
    Advance one generation.
    """
    self.__model.evolve()
    self.__update_display()
</code></pre>

<div class="explication">
<strong>MÃ©thode ultra-simple grÃ¢ce au MVC :</strong>
<p>
Cette mÃ©thode fait juste 2 choses :
</p>
<ol>
    <li><strong>model.evolve() :</strong> Demande au ModÃ¨le d'Ã©voluer (logique mÃ©tier)</li>
    <li><strong>__update_display() :</strong> Met Ã  jour l'affichage (prÃ©sentation)</li>
</ol>
<p>
GrÃ¢ce Ã  la sÃ©paration MVC, le Controller n'a pas besoin de savoir COMMENT le modÃ¨le Ã©volue ni COMMENT la vue affiche. Il coordonne simplement les deux !
</p>
</div>

<h4>5.3.3. on_canvas_click() : Clic sur le canvas</h4>

<pre><code class="python">
def on_canvas_click(self, event):
    """
    Handle canvas click event.
    Toggle clicked cell.

    Args:
        event: Tkinter event with x, y coordinates
    """
    # Get model coordinates from canvas click
    row, col = self.__view.canvas.get_cell_from_click(event)

    # Toggle cell in model
    self.__model.toggle_cell(row, col)

    # Update display
    self.__update_display()
</code></pre>

<div class="explication">
<strong>Flux complet d'un clic :</strong>
<ol>
    <li><strong>Utilisateur clique</strong> sur le canvas Ã  (x=37, y=52) pixels</li>
    <li><strong>Tkinter gÃ©nÃ¨re un event</strong> avec event.x=37, event.y=52</li>
    <li><strong>Controller reÃ§oit l'event</strong> via on_canvas_click(event)</li>
    <li><strong>Controller demande Ã  la Vue</strong> de convertir pixels â†’ indices : canvas.get_cell_from_click(event) â†’ (5, 3)</li>
    <li><strong>Controller demande au ModÃ¨le</strong> de toggler la cellule : model.toggle_cell(5, 3)</li>
    <li><strong>ModÃ¨le modifie la cellule</strong> et appelle notify_observers()</li>
    <li><strong>Controller est notifiÃ©</strong> via update() qui appelle __update_display()</li>
    <li><strong>Vue redessine</strong> la grille avec la cellule modifiÃ©e</li>
</ol>
</div>

<div class="important">
<strong>SÃ©paration des responsabilitÃ©s :</strong>
<ul>
    <li>âœ… <strong>Vue :</strong> Sait convertir pixels â†’ indices (get_cell_from_click)</li>
    <li>âœ… <strong>ModÃ¨le :</strong> Sait modifier l'Ã©tat de la cellule (toggle_cell)</li>
    <li>âœ… <strong>Controller :</strong> Coordonne les deux</li>
</ul>
<p>
Chaque composant fait CE QU'IL SAIT FAIRE et rien d'autre !
</p>
</div>

<h3 id="controller-animation">5.4. Boucle d'animation</h3>

<pre><code class="python">
def __animate(self):
    """
    Private method: Animation loop.

    This method calls itself recursively using after()
    to create the animation effect.
    """
    if self.__is_running:
        # Evolve one generation
        self.__model.evolve()

        # Update display
        self.__update_display()

        # Schedule next animation frame
        self.__view.root.after(self.__animation_speed, self.__animate)
</code></pre>

<div class="concept">
<strong>RÃ©cursion asynchrone avec after() :</strong>
<p>
La mÃ©thode after() de Tkinter est la clÃ© de l'animation. Elle programme l'exÃ©cution d'une fonction APRÃˆS un certain dÃ©lai :
</p>
<pre><code class="python">
self.__view.root.after(100, self.__animate)
# "Appelle self.__animate() dans 100 millisecondes"
</code></pre>
<p>
Comme __animate() s'appelle elle-mÃªme via after(), cela crÃ©e une boucle infinie contrÃ´lÃ©e par __is_running.
</p>
</div>

<div class="explication">
<strong>DÃ©roulement de l'animation :</strong>
<ol>
    <li>Utilisateur clique "Start" â†’ on_start_stop() met is_running=True et appelle __animate()</li>
    <li>__animate() vÃ©rifie is_running â†’ True, continue</li>
    <li>__animate() appelle model.evolve() â†’ gÃ©nÃ©ration suivante</li>
    <li>__animate() appelle __update_display() â†’ redessine</li>
    <li>__animate() programme un nouvel appel : after(100, __animate)</li>
    <li><strong>100ms plus tard</strong>, __animate() est rappelÃ© â†’ retour Ã  l'Ã©tape 2</li>
    <li>Utilisateur clique "Stop" â†’ on_start_stop() met is_running=False</li>
    <li>__animate() vÃ©rifie is_running â†’ False, ne fait rien â†’ animation arrÃªtÃ©e</li>
</ol>
</div>

<div class="important">
<strong>Pourquoi after() et pas une boucle while ?</strong>
<p>
âŒ <strong>NE PAS FAIRE Ã‡A :</strong>
</p>
<pre><code class="python">
# FAUX - Bloque l'interface !
while is_running:
    model.evolve()
    update_display()
    time.sleep(0.1)  # âŒ Bloque TOUT, interface non rÃ©active
</code></pre>
<p>
<strong>ProblÃ¨me :</strong> La boucle while bloque le thread principal. L'interface ne peut plus rÃ©pondre aux clics, la fenÃªtre se fige !
</p>

<p>
âœ… <strong>CORRECT :</strong>
</p>
<pre><code class="python">
# CORRECT - Non bloquant
def animate(self):
    if is_running:
        model.evolve()
        update_display()
        root.after(100, self.animate)  # âœ… Rend le contrÃ´le Ã  Tkinter
</code></pre>
<p>
<strong>Solution :</strong> after() programme l'appel et REND LE CONTRÃ”LE Ã  Tkinter. L'interface reste rÃ©active !
</p>
</div>

<!-- ================================================================== -->
<!-- CHAPITRE 6: LIVECOUNTER.PY - MODULE DE STATISTIQUES             -->
<!-- ================================================================== -->

<h2 id="chapter-livecounter">6. LIVECOUNTER.PY - Module de statistiques</h2>

<div class="concept">
<strong>Livecounter : SÃ©paration des prÃ©occupations (Separation of Concerns)</strong>
<p>
Ce module est un excellent exemple du principe de sÃ©paration des prÃ©occupations en OOP. Au lieu de mÃ©langer la logique de statistiques dans le ModÃ¨le ou le Controller, on crÃ©e une classe DÃ‰DIÃ‰E pour Ã§a.
</p>
</div>

<pre><code class="python">
class LiveCounter:
    """
    Tracks statistics for the Game of Life.

    Responsibilities:
    - Count generations
    - Count alive cells
    - Track population history
    - Calculate statistics

    Optional feature but demonstrates good separation of concerns.
    """

    def __init__(self):
        """
        Initialize the counter.
        """
        self.__generation_count = 0
        self.__alive_cells_count = 0
        self.__population_history = []
        self.__max_population = 0
        self.__min_population = 0
</code></pre>

<h3>count_alive_cells() : Compter les cellules vivantes</h3>

<pre><code class="python">
def count_alive_cells(self, grid):
    """
    Count alive cells in a grid and update statistics.

    Args:
        grid: 2D list of LiveCell objects

    Returns:
        int: Number of alive cells
    """
    count = 0
    for row in grid:
        for cell in row:
            if cell.state:
                count += 1

    self.update_alive_count(count)
    return count
</code></pre>

<div class="explication">
<strong>Parcours simplifiÃ© de la grille :</strong>
<p>
Remarquez l'Ã©lÃ©gance du parcours :
</p>
<pre><code class="python">
for row in grid:          # Pour chaque ligne
    for cell in row:      # Pour chaque cellule dans la ligne
        if cell.state:    # Si vivante
            count += 1    # IncrÃ©menter
</code></pre>
<p>
Pas besoin d'indices ! On itÃ¨re directement sur les objets.
</p>
</div>

<!-- ================================================================== -->
<!-- CHAPITRE 7: MAIN.PY - POINT D'ENTRÃ‰E                             -->
<!-- ================================================================== -->

<h2 id="chapter-main">7. MAIN.PY - Point d'entrÃ©e de l'application</h2>

<div class="concept">
<strong>Le main() minimal :</strong>
<p>
Le fichier main.py devrait Ãªtre ULTRA-SIMPLE. Pas de logique mÃ©tier, pas de calculs, juste :
</p>
<ol>
    <li>CrÃ©er le ModÃ¨le</li>
    <li>CrÃ©er la Vue</li>
    <li>CrÃ©er le Controller</li>
    <li>Lancer l'application</li>
</ol>
</div>

<pre><code class="python">
def main():
    """
    Main function to start the Game of Life application.

    Creates Model, View, and Controller in proper order:
    1. Create Model (independent)
    2. Create View (independent)
    3. Create Controller (coordinates Model and View)
    4. Run the application
    """

    # Configuration
    GRID_WIDTH = 40  # Number of cells horizontally
    GRID_HEIGHT = 40  # Number of cells vertically
    WINDOW_TITLE = "Conway's Game of Life - Q54 Project"

    # Step 1: Create Model
    print("Creating Model...")
    model = LiveModel(width=GRID_WIDTH, height=GRID_HEIGHT)

    # Step 2: Create View
    print("Creating View...")
    view = LiveView(title=WINDOW_TITLE)

    # Step 3: Create Controller (connects Model and View)
    print("Creating Controller...")
    controller = LiveController(model, view)

    # Step 4: Run the application
    print("Starting Game of Life...")
    controller.run()

    print("\nApplication closed.")


if __name__ == "__main__":
    """
    Entry point when running as main module.
    """
    main()
</code></pre>

<div class="important">
<strong>Ordre de crÃ©ation MVC :</strong>
<ol>
    <li><strong>Model FIRST :</strong> Le modÃ¨le est indÃ©pendant, il peut exister seul</li>
    <li><strong>View SECOND :</strong> La vue est aussi indÃ©pendante, elle ne connaÃ®t ni Model ni Controller</li>
    <li><strong>Controller LAST :</strong> Le controller connecte Model et View, il a donc besoin que les deux existent d'abord</li>
</ol>
<p>
Si on crÃ©ait le Controller avant le Model ou la View, on aurait une erreur (paramÃ¨tres manquants) !
</p>
</div>

<!-- ================================================================== -->
<!-- CHAPITRE 8: SYNTHÃˆSE DES DESIGN PATTERNS                         -->
<!-- ================================================================== -->

<h2 id="chapter-patterns">8. SYNTHÃˆSE DES DESIGN PATTERNS UTILISÃ‰S</h2>

<div class="concept">
<strong>Les Design Patterns (Patrons de Conception)</strong>
<p>
Les Design Patterns sont des solutions Ã©prouvÃ©es Ã  des problÃ¨mes rÃ©currents en programmation. Ce sont des "recettes" que les dÃ©veloppeurs expÃ©rimentÃ©s utilisent pour crÃ©er du code maintenable et Ã©volutif.
</p>
</div>

<h3 id="pattern-mvc">8.1. MVC (Model-View-Controller) - Pattern Architectural</h3>

<div class="pattern">
<strong>ProblÃ¨me rÃ©solu :</strong>
<p>
Comment sÃ©parer la logique mÃ©tier, la prÃ©sentation et la coordination dans une application interactive ?
</p>

<strong>Solution MVC :</strong>
<ul>
    <li><strong>Model :</strong> GÃ¨re les donnÃ©es et la logique mÃ©tier (livemodel.py)</li>
    <li><strong>View :</strong> GÃ¨re l'affichage et l'interface utilisateur (liveview.py)</li>
    <li><strong>Controller :</strong> Coordonne Model et View, gÃ¨re les Ã©vÃ©nements (livecontroller.py)</li>
</ul>

<strong>Avantages dans notre projet :</strong>
<ul>
    <li>âœ… Le modÃ¨le peut Ãªtre testÃ© SANS interface graphique</li>
    <li>âœ… On peut changer l'interface (Tkinter â†’ PyQt) sans toucher au modÃ¨le</li>
    <li>âœ… Plusieurs vues peuvent afficher le mÃªme modÃ¨le</li>
    <li>âœ… Le code est organisÃ© de maniÃ¨re claire et logique</li>
</ul>
</div>

<div class="exemple">
<strong>Flux typique dans notre application MVC :</strong>
<pre>
1. Utilisateur clique sur "Step"
   â†“
2. VIEW capture l'Ã©vÃ©nement
   â†“
3. VIEW appelle CONTROLLER.on_step()
   â†“
4. CONTROLLER appelle MODEL.evolve()
   â†“
5. MODEL calcule la nouvelle gÃ©nÃ©ration
   â†“
6. MODEL notifie le CONTROLLER (Observer Pattern)
   â†“
7. CONTROLLER demande Ã  VIEW d'afficher
   â†“
8. VIEW redessine la grille
   â†“
9. Utilisateur voit le rÃ©sultat
</pre>
</div>

<h3 id="pattern-observer">8.2. OBSERVER PATTERN (Observateur)</h3>

<div class="pattern">
<strong>ProblÃ¨me rÃ©solu :</strong>
<p>
Comment notifier automatiquement plusieurs objets quand l'Ã©tat d'un objet change, sans crÃ©er de couplage fort ?
</p>

<strong>Solution Observer :</strong>
<ul>
    <li><strong>Observable (Subject) :</strong> L'objet observÃ© (LiveModel)</li>
    <li><strong>Observer :</strong> Les objets qui veulent Ãªtre notifiÃ©s (LiveController)</li>
    <li><strong>MÃ©canisme :</strong> Le Subject maintient une liste d'Observers et les notifie via update()</li>
</ul>

<strong>ImplÃ©mentation dans notre projet :</strong>
<ul>
    <li><strong>Observable :</strong> Classe abstraite avec attach(), detach(), notify_observers()</li>
    <li><strong>Observer :</strong> Classe abstraite avec update(subject)</li>
    <li><strong>LiveModel hÃ©rite d'Observable</strong></li>
    <li><strong>LiveController hÃ©rite d'Observer</strong></li>
</ul>
</div>

<div class="important">
<strong>Avantages :</strong>
<ul>
    <li>âœ… <strong>DÃ©couplage :</strong> Le Model ne connaÃ®t PAS le Controller (juste qu'il est un Observer)</li>
    <li>âœ… <strong>ExtensibilitÃ© :</strong> On peut ajouter d'autres Observers (Logger, Saver) sans modifier le Model</li>
    <li>âœ… <strong>Automatique :</strong> Le Controller est notifiÃ© AUTOMATIQUEMENT Ã  chaque changement</li>
</ul>
</div>

<div class="exemple">
<strong>Code clÃ© du Pattern Observer :</strong>

<pre><code class="python">
# Dans LiveModel (Observable)
class LiveModel(Observable):
    def __init__(self):
        self.__observers = []  # Liste des observateurs

    def attach(self, observer):
        self.__observers.append(observer)  # Enregistrer un observateur

    def notify_observers(self):
        for observer in self.__observers:
            observer.update(self)  # Notifier tous les observateurs

    def evolve(self):
        # ... logique d'Ã©volution ...
        self.notify_observers()  # âœ… Notification automatique !

# Dans LiveController (Observer)
class LiveController(Observer):
    def __init__(self, model, view):
        self.__model = model
        self.__model.attach(self)  # S'enregistrer comme observateur

    def update(self, subject):
        self.__update_display()  # âœ… Mise Ã  jour automatique !
</code></pre>
</div>

<h3 id="pattern-strategy">8.3. STRATEGY PATTERN (StratÃ©gie)</h3>

<div class="pattern">
<strong>ProblÃ¨me rÃ©solu :</strong>
<p>
Comment permettre de changer dynamiquement l'algorithme utilisÃ© sans modifier le code qui l'utilise ?
</p>

<strong>Solution Strategy :</strong>
<ul>
    <li><strong>Interface Strategy :</strong> DÃ©finit le contrat (ConfigurationStrategy)</li>
    <li><strong>Concrete Strategies :</strong> ImplÃ©mentent diffÃ©rents algorithmes (EmptyStrategy, RandomStrategy, CannonStrategy)</li>
    <li><strong>Context :</strong> Utilise une stratÃ©gie sans connaÃ®tre ses dÃ©tails (LiveModel)</li>
</ul>
</div>

<div class="explication">
<strong>Dans notre projet :</strong>

<p>
Au lieu de faire :
</p>
<pre><code class="python">
# âŒ Sans Strategy Pattern
def configure_grid(self, config_type):
    if config_type == "empty":
        # Code pour vider la grille
    elif config_type == "random":
        # Code pour configuration alÃ©atoire
    elif config_type == "cannon":
        # Code pour le canon
    # Et si on veut ajouter une nouvelle configuration ?
    # Il faut MODIFIER cette mÃ©thode (viole Open/Closed Principle)
</code></pre>

<p>
Avec Strategy Pattern :
</p>
<pre><code class="python">
# âœ… Avec Strategy Pattern
model.apply_configuration_strategy(EmptyStrategy())
model.apply_configuration_strategy(RandomStrategy(0.25))
model.apply_configuration_strategy(CannonStrategy())
# Pour ajouter une nouvelle configuration :
# CrÃ©er une nouvelle classe qui hÃ©rite de ConfigurationStrategy
# SANS modifier le code existant !
</code></pre>
</div>

<div class="important">
<strong>Avantages :</strong>
<ul>
    <li>âœ… <strong>Open/Closed Principle :</strong> Ouvert Ã  l'extension, fermÃ© Ã  la modification</li>
    <li>âœ… <strong>TestabilitÃ© :</strong> Chaque stratÃ©gie peut Ãªtre testÃ©e indÃ©pendamment</li>
    <li>âœ… <strong>ClartÃ© :</strong> Chaque algorithme est dans sa propre classe, pas de if/else gÃ©ant</li>
    <li>âœ… <strong>RÃ©utilisabilitÃ© :</strong> Les stratÃ©gies peuvent Ãªtre rÃ©utilisÃ©es dans d'autres contextes</li>
</ul>
</div>

<h3 id="pattern-singleton">8.4. SINGLETON PATTERN</h3>

<div class="pattern">
<strong>ProblÃ¨me rÃ©solu :</strong>
<p>
Comment garantir qu'une classe n'a qu'UNE SEULE instance et fournir un point d'accÃ¨s global Ã  cette instance ?
</p>

<strong>Solution Singleton :</strong>
<pre><code class="python">
class LiveModel(Observable):
    __instance = None  # Attribut de classe (partagÃ© par toutes les instances)

    @classmethod
    def singleton(cls, width=40, height=40):
        """Get the single instance of LiveModel."""
        if cls.__instance is None:
            cls.__instance = cls(width, height)  # CrÃ©er SEULE instance
        return cls.__instance  # Retourner l'instance existante
</code></pre>
</div>

<div class="pourquoi">
<strong>Pourquoi utiliser Singleton pour le Model ?</strong>
<ul>
    <li><strong>CohÃ©rence :</strong> Un seul Ã©tat de jeu dans toute l'application</li>
    <li><strong>Performance :</strong> Ã‰vite de crÃ©er plusieurs grilles 40x40 en mÃ©moire</li>
    <li><strong>AccÃ¨s global :</strong> N'importe quelle partie du code peut accÃ©der au modÃ¨le unique</li>
</ul>

<strong>InconvÃ©nients (pourquoi nous ne l'utilisons PAS dans main.py) :</strong>
<ul>
    <li>âŒ Rend les tests plus difficiles (Ã©tat partagÃ© entre tests)</li>
    <li>âŒ CrÃ©e un couplage global</li>
    <li>âŒ Dans notre cas, MVC avec injection de dÃ©pendances est prÃ©fÃ©rable</li>
</ul>
</div>

<h3 id="pattern-iterator">8.5. ITERATOR PATTERN (ItÃ©rateur)</h3>

<div class="pattern">
<strong>ProblÃ¨me rÃ©solu :</strong>
<p>
Comment parcourir les Ã©lÃ©ments d'une collection sans exposer sa reprÃ©sentation interne ?
</p>

<strong>Solution Iterator :</strong>
<pre><code class="python">
def __grid_iterator(self, grid):
    """Generator that yields all cells with coordinates."""
    for row in range(len(grid)):
        for col in range(len(grid[row])):
            yield (row, col, grid[row][col])

# Utilisation
for row, col, cell in self.__grid_iterator(grid):
    self.draw_cell(row, col, cell.state, cell.age)
</code></pre>
</div>

<div class="important">
<strong>Avantages des gÃ©nÃ©rateurs Python :</strong>
<ul>
    <li>âœ… <strong>MÃ©moire :</strong> Ne crÃ©e pas de liste intermÃ©diaire (yield produit une valeur Ã  la fois)</li>
    <li>âœ… <strong>LisibilitÃ© :</strong> Une seule boucle for au lieu de deux imbriquÃ©es</li>
    <li>âœ… <strong>Encapsulation :</strong> La logique de parcours est cachÃ©e</li>
    <li>âœ… <strong>FlexibilitÃ© :</strong> Facile de changer l'ordre de parcours</li>
</ul>
</div>

<!-- ================================================================== -->
<!-- CHAPITRE 9: PRINCIPES OOP APPLIQUÃ‰S                              -->
<!-- ================================================================== -->

<h2 id="chapter-oop">9. PRINCIPES OOP (POO) APPLIQUÃ‰S</h2>

<h3 id="oop-encapsulation">9.1. ENCAPSULATION</h3>

<div class="concept">
<strong>DÃ©finition :</strong>
<p>
L'encapsulation consiste Ã  cacher les dÃ©tails d'implÃ©mentation et Ã  ne exposer que ce qui est nÃ©cessaire via une interface publique.
</p>
</div>

<div class="explication">
<strong>Dans notre projet :</strong>

<h4>Attributs privÃ©s (__ double underscore) :</h4>
<pre><code class="python">
class LiveCell:
    def __init__(self, state=False):
        self.__state = state          # PrivÃ© - pas d'accÃ¨s direct
        self.__neighbors_count = 0    # PrivÃ©
        self.__age = 0                # PrivÃ©

    @property
    def state(self):
        """Public getter"""
        return self.__state

    @state.setter
    def state(self, value):
        """Public setter avec validation possible"""
        self.__state = value
</code></pre>

<h4>MÃ©thodes privÃ©es :</h4>
<pre><code class="python">
class LiveModel:
    # MÃ©thodes publiques (interface publique)
    def evolve(self):  # âœ… Public
        self.__update_neighbors_count()  # Appelle mÃ©thode privÃ©e

    # MÃ©thodes privÃ©es (dÃ©tails d'implÃ©mentation)
    def __create_grid(self):  # âŒ PrivÃ© - usage interne seulement
        ...

    def __count_neighbors(self, row, col):  # âŒ PrivÃ©
        ...

    def __update_neighbors_count(self):  # âŒ PrivÃ©
        ...
</code></pre>
</div>

<div class="important">
<strong>Avantages de l'encapsulation :</strong>
<ul>
    <li>âœ… <strong>Protection :</strong> EmpÃªche la modification accidentelle de l'Ã©tat interne</li>
    <li>âœ… <strong>Validation :</strong> Les setters peuvent valider les valeurs avant de les accepter</li>
    <li>âœ… <strong>FlexibilitÃ© :</strong> On peut changer l'implÃ©mentation interne sans affecter le code qui utilise la classe</li>
    <li>âœ… <strong>Maintenance :</strong> RÃ©duit les dÃ©pendances entre les parties du code</li>
</ul>
</div>

<h3 id="oop-abstraction">9.2. ABSTRACTION</h3>

<div class="concept">
<strong>DÃ©finition :</strong>
<p>
L'abstraction consiste Ã  dÃ©finir des interfaces (contrats) que les classes concrÃ¨tes doivent implÃ©menter, sans spÃ©cifier comment.
</p>
</div>

<div class="explication">
<strong>Classes abstraites avec ABC (Abstract Base Class) :</strong>

<pre><code class="python">
from abc import ABC, abstractmethod

class Observer(ABC):
    """Interface Observer - dÃ©fini le CONTRAT"""
    @abstractmethod
    def update(self, subject):
        """MÃ©thode abstraite - DOIT Ãªtre implÃ©mentÃ©e par les sous-classes"""
        pass

class Observable(ABC):
    """Interface Observable - dÃ©finit le CONTRAT"""
    @abstractmethod
    def attach(self, observer):
        pass

    @abstractmethod
    def detach(self, observer):
        pass

    @abstractmethod
    def notify_observers(self):
        pass

# Classes concrÃ¨tes qui implÃ©mentent les interfaces
class LiveModel(Observable):
    """ImplÃ©mentation concrÃ¨te d'Observable"""
    def attach(self, observer):
        # ImplÃ©mentation concrÃ¨te
        self.__observers.append(observer)
    # ... autres mÃ©thodes ...

class LiveController(Observer):
    """ImplÃ©mentation concrÃ¨te d'Observer"""
    def update(self, subject):
        # ImplÃ©mentation concrÃ¨te
        self.__update_display()
</code></pre>
</div>

<div class="important">
<strong>Avantages de l'abstraction :</strong>
<ul>
    <li>âœ… <strong>Contrat clair :</strong> Les interfaces dÃ©finissent exactement ce qui doit Ãªtre implÃ©mentÃ©</li>
    <li>âœ… <strong>Polymorphisme :</strong> On peut traiter diffÃ©rentes implÃ©mentations de la mÃªme maniÃ¨re</li>
    <li>âœ… <strong>Documentation :</strong> Les interfaces servent de documentation pour les dÃ©veloppeurs</li>
    <li>âœ… <strong>SÃ©curitÃ© :</strong> Python empÃªche d'instancier une classe abstraite incomplÃ¨te</li>
</ul>
</div>

<h3 id="oop-composition">9.3. COMPOSITION</h3>

<div class="concept">
<strong>DÃ©finition :</strong>
<p>
La composition consiste Ã  construire des objets complexes en combinant des objets plus simples. "Has-a" au lieu de "Is-a".
</p>
</div>

<div class="explication">
<strong>Exemples dans notre projet :</strong>

<h4>LiveModel contient (has-a) une grille de LiveCell :</h4>
<pre><code class="python">
class LiveModel:
    def __init__(self, width, height):
        self.__grid = []  # LiveModel HAS-A grid
        for row in range(height):
            row_cells = []
            for col in range(width):
                row_cells.append(LiveCell())  # LiveModel HAS-A collection of LiveCell
            self.__grid.append(row_cells)
</code></pre>

<h4>LiveView contient (has-a) LiveCanvas et LiveCommandBar :</h4>
<pre><code class="python">
class LiveView:
    def __init__(self, title):
        self.__root = Tk()
        self.__canvas = None         # LiveView HAS-A LiveCanvas
        self.__command_bar = None    # LiveView HAS-A LiveCommandBar
        self.__status_label = None   # LiveView HAS-A Label

    def create_canvas(self, width, height):
        self.__canvas = LiveCanvas(self.__root, width, height)  # Composition
        return self.__canvas
</code></pre>

<h4>LiveController contient (has-a) Model, View et Counter :</h4>
<pre><code class="python">
class LiveController:
    def __init__(self, model, view):
        self.__model = model          # Controller HAS-A Model
        self.__view = view            # Controller HAS-A View
        self.__counter = LiveCounter()  # Controller HAS-A Counter
</code></pre>
</div>

<div class="important">
<strong>Composition vs HÃ©ritage :</strong>
<table border="1" cellpadding="8">
<tr>
    <th>CritÃ¨re</th>
    <th>HÃ©ritage (Is-a)</th>
    <th>Composition (Has-a)</th>
</tr>
<tr>
    <td><strong>Relation</strong></td>
    <td>LiveController IS-A Observer</td>
    <td>LiveController HAS-A Model</td>
</tr>
<tr>
    <td><strong>Couplage</strong></td>
    <td>Fort (dÃ©pend de la classe parent)</td>
    <td>Faible (dÃ©pend seulement de l'interface)</td>
</tr>
<tr>
    <td><strong>FlexibilitÃ©</strong></td>
    <td>Rigide (hiÃ©rarchie fixe)</td>
    <td>Flexible (peut changer les composants)</td>
</tr>
<tr>
    <td><strong>Quand utiliser ?</strong></td>
    <td>Relation "est un"</td>
    <td>Relation "a un"</td>
</tr>
</table>

<p>
<strong>Principe :</strong> "Favor composition over inheritance" (PrÃ©fÃ©rez la composition Ã  l'hÃ©ritage)
</p>
</div>

<h3 id="oop-polymorphism">9.4. POLYMORPHISME</h3>

<div class="concept">
<strong>DÃ©finition :</strong>
<p>
Le polymorphisme permet de traiter diffÃ©rents types d'objets de maniÃ¨re uniforme via une interface commune.
</p>
</div>

<div class="explication">
<strong>Polymorphisme avec le Strategy Pattern :</strong>

<pre><code class="python">
# Toutes les stratÃ©gies implÃ©mentent la mÃªme interface
class ConfigurationStrategy(ABC):
    @abstractmethod
    def apply(self, model):
        pass

class EmptyStrategy(ConfigurationStrategy):
    def apply(self, model):
        # ImplÃ©mentation spÃ©cifique pour vider
        ...

class RandomStrategy(ConfigurationStrategy):
    def apply(self, model):
        # ImplÃ©mentation spÃ©cifique pour alÃ©atoire
        ...

class CannonStrategy(ConfigurationStrategy):
    def apply(self, model):
        # ImplÃ©mentation spÃ©cifique pour le canon
        ...

# Le Model traite TOUTES les stratÃ©gies de la mÃªme maniÃ¨re !
def apply_configuration_strategy(self, strategy):
    strategy.apply(self)  # âœ… Polymorphisme : appel uniforme
    self.notify_observers()

# Utilisation
model.apply_configuration_strategy(EmptyStrategy())   # âœ…
model.apply_configuration_strategy(RandomStrategy())  # âœ…
model.apply_configuration_strategy(CannonStrategy())  # âœ…
# Toutes les stratÃ©gies sont traitÃ©es de maniÃ¨re uniforme !
</code></pre>
</div>

<div class="important">
<strong>Avantages du polymorphisme :</strong>
<ul>
    <li>âœ… <strong>Code gÃ©nÃ©rique :</strong> Une mÃ©thode qui fonctionne avec plusieurs types</li>
    <li>âœ… <strong>ExtensibilitÃ© :</strong> Ajouter de nouveaux types sans modifier le code existant</li>
    <li>âœ… <strong>SimplicitÃ© :</strong> Pas besoin de if/elif/else pour distinguer les types</li>
</ul>
</div>

<!-- ================================================================== -->
<!-- CHAPITRE 10: COMPARAISON PROCÃ‰DURAL VS OOP                       -->
<!-- ================================================================== -->

<h2 id="chapter-comparison">10. COMPARAISON : VERSION PROCÃ‰DURALE VS VERSION OOP</h2>

<h3 id="comp-structure">10.1. Structure du code</h3>

<div class="explication">
<h4>Version ProcÃ©durale (AVANT) :</h4>
<pre>
game_of_life.py (UN SEUL FICHIER, 500+ lignes)
â”œâ”€â”€ Variables globales (grid, generation, c, etc.)
â”œâ”€â”€ Fonction init_grid()
â”œâ”€â”€ Fonction count_neighbors()
â”œâ”€â”€ Fonction evolve()
â”œâ”€â”€ Fonction draw_grid()
â”œâ”€â”€ Fonction on_click()
â”œâ”€â”€ Fonctions de configuration (random, cannon)
â””â”€â”€ Code principal mÃ©langÃ©
</pre>

<h4>Version OOP (APRÃˆS) :</h4>
<pre>
GameOfLife/ (STRUCTURE MODULAIRE)
â”œâ”€â”€ livemodel.py (Logique mÃ©tier - 643 lignes)
â”‚   â”œâ”€â”€ Observer (interface)
â”‚   â”œâ”€â”€ Observable (interface)
â”‚   â”œâ”€â”€ ConfigurationStrategy (interface)
â”‚   â”œâ”€â”€ EmptyStrategy, RandomStrategy, CannonStrategy
â”‚   â”œâ”€â”€ LiveCell (classe de donnÃ©es)
â”‚   â””â”€â”€ LiveModel (modÃ¨le principal)
â”œâ”€â”€ liveview.py (Interface - 474 lignes)
â”‚   â”œâ”€â”€ LiveCanvas (affichage grille)
â”‚   â”œâ”€â”€ LiveCommandBar (boutons)
â”‚   â””â”€â”€ LiveView (vue principale)
â”œâ”€â”€ livecontroller.py (Coordination - 279 lignes)
â”‚   â””â”€â”€ LiveController (coordonne Model et View)
â”œâ”€â”€ livecounter.py (Statistiques - 175 lignes)
â”‚   â””â”€â”€ LiveCounter (compteur de population)
â””â”€â”€ main.py (Point d'entrÃ©e - 69 lignes)
    â””â”€â”€ main() (instanciation MVC)

TOTAL: ~1640 lignes MAIS mieux organisÃ©es et rÃ©utilisables !
</pre>
</div>

<div class="important">
<strong>Analyse :</strong>
<ul>
    <li>âœ… OOP : Code organisÃ© par responsabilitÃ© (chaque fichier a un rÃ´le clair)</li>
    <li>âœ… OOP : Facilite la navigation (chercher une fonctionnalitÃ© = savoir quel fichier)</li>
    <li>âœ… OOP : Permet le travail en Ã©quipe (chaque membre travaille sur un fichier diffÃ©rent)</li>
    <li>âŒ ProcÃ©dural : Tout dans un fichier = difficile Ã  naviguer et Ã  maintenir</li>
</ul>
</div>

<h3 id="comp-indices">10.2. Gestion des indices vs pixels</h3>

<div class="explication">
<h4>Version ProcÃ©durale (INCORRECTE) :</h4>
<pre><code class="python">
# âŒ MÃ©lange indices et pixels !
c = 10  # Taille de cellule en pixels

# CrÃ©ation de la grille avec multiplications
for i in range(l):
    for j in range(h):
        grid[i*c][j*c] = 0  # âŒ Utilise i*c comme indice !

# Pattern du canon avec multiplications
pattern = [(5*c, 1*c), (5*c, 2*c), ...]  # âŒ CoordonnÃ©es en pixels !

# Conversion clic avec modulo (INCORRECT !)
col = event.x % c  # âŒ Donne le RESTE, pas l'indice !
row = event.y % c  # âŒ Incorrect !
</code></pre>

<h4>Version OOP (CORRECTE) :</h4>
<pre><code class="python">
# âœ… SÃ©paration claire indices / pixels

# Model : indices purs (0, 1, 2, 3...)
class LiveModel:
    def __create_grid(self):
        for row in range(self.__height):  # âœ… Indices : 0, 1, 2...
            for col in range(self.__width):  # âœ… Indices : 0, 1, 2...
                self.__grid[row][col] = LiveCell()  # âœ… AccÃ¨s direct

# Model : pattern avec indices purs
pattern = [(5, 1), (5, 2), (6, 1), (6, 2)]  # âœ… CoordonnÃ©es logiques !

# View : conversion indices â†’ pixels (CORRECT !)
class LiveCanvas:
    def __model_to_canvas(self, row, col):
        x1 = col * self.__cell_size  # âœ… Multiplication pour affichage
        y1 = row * self.__cell_size
        return (x1, y1, x2, y2)

    def __canvas_to_model(self, x, y):
        col = x // self.__cell_size  # âœ… Division entiÃ¨re (pas modulo !)
        row = y // self.__cell_size
        return (row, col)
</code></pre>
</div>

<div class="important">
<strong>Impact de cette correction :</strong>
<ul>
    <li>âœ… Code MODEL comprÃ©hensible : grid[5][3] = cellule Ã  la ligne 5, colonne 3</li>
    <li>âœ… FlexibilitÃ© : changer cell_size ne modifie PAS la logique mÃ©tier</li>
    <li>âœ… TestabilitÃ© : on peut tester le modÃ¨le avec des indices simples</li>
    <li>âœ… Maintenance : clartÃ© sur ce qui reprÃ©sente quoi</li>
</ul>
</div>

<h3 id="comp-testability">10.3. TestabilitÃ©</h3>

<div class="explication">
<h4>Version ProcÃ©durale :</h4>
<pre><code class="python">
# âŒ Impossible de tester la logique sans lancer l'interface
# Variables globales
grid = []
generation = 0

def evolve():
    global grid, generation  # âŒ DÃ©pend de l'Ã©tat global
    # ... logique ...

# Pour tester evolve(), il faut :
# 1. Initialiser les variables globales
# 2. CrÃ©er une fenÃªtre Tkinter (mÃªme pour un test unitaire !)
# 3. Impossible de tester en parallÃ¨le (Ã©tat partagÃ©)
</code></pre>

<h4>Version OOP :</h4>
<pre><code class="python">
# âœ… Facile de tester chaque composant isolÃ©ment

# Test du Model SANS interface graphique
def test_evolve_blinker():
    # CrÃ©er un modÃ¨le de test
    model = LiveModel(width=10, height=10)

    # Configuration initiale (blinker horizontal)
    model.set_cell_state(5, 4, True)
    model.set_cell_state(5, 5, True)
    model.set_cell_state(5, 6, True)

    # Ã‰voluer
    model.evolve()

    # VÃ©rifier (blinker vertical)
    assert model.get_cell_state(4, 5) == True
    assert model.get_cell_state(5, 5) == True
    assert model.get_cell_state(6, 5) == True
    assert model.get_cell_state(5, 4) == False  # âœ… Test passÃ© !

# Test des stratÃ©gies
def test_random_strategy():
    model = LiveModel(width=10, height=10)
    strategy = RandomStrategy(alive_percentage=0.5)
    strategy.apply(model)
    # VÃ©rifier qu'environ 50% des cellules sont vivantes
    # ...
</code></pre>
</div>

<h3 id="comp-maintainability">10.4. MaintenabilitÃ© et Ã‰volutivitÃ©</h3>

<div class="explication">
<table border="1" cellpadding="10">
<tr>
    <th>ScÃ©nario</th>
    <th>Version ProcÃ©durale</th>
    <th>Version OOP</th>
</tr>
<tr>
    <td><strong>Ajouter une nouvelle configuration</strong></td>
    <td>
        âŒ Modifier la fonction principale<br>
        âŒ Ajouter if/elif dans le code<br>
        âŒ Risque de casser l'existant
    </td>
    <td>
        âœ… CrÃ©er nouvelle classe Strategy<br>
        âœ… Aucune modification du code existant<br>
        âœ… Open/Closed Principle
    </td>
</tr>
<tr>
    <td><strong>Changer l'interface (Tkinter â†’ PyQt)</strong></td>
    <td>
        âŒ RÃ©Ã©crire tout le code<br>
        âŒ Logique mÃ©tier mÃ©langÃ©e Ã  l'UI<br>
        âŒ Impossible de rÃ©utiliser
    </td>
    <td>
        âœ… Remplacer seulement liveview.py<br>
        âœ… Model et Controller inchangÃ©s<br>
        âœ… RÃ©utilisation facile
    </td>
</tr>
<tr>
    <td><strong>Ajouter un systÃ¨me de sauvegarde</strong></td>
    <td>
        âŒ Ajouter des fonctions globales<br>
        âŒ Modifier la logique existante<br>
        âŒ DÃ©pendances partout
    </td>
    <td>
        âœ… CrÃ©er nouvelle classe Saver<br>
        âœ… ImplÃ©menter Observer<br>
        âœ… model.attach(saver) â†’ fait !
    </td>
</tr>
<tr>
    <td><strong>DÃ©bugger un problÃ¨me</strong></td>
    <td>
        âŒ Chercher dans 500+ lignes<br>
        âŒ Code entremÃªlÃ©<br>
        âŒ Difficile de localiser
    </td>
    <td>
        âœ… Bug dans les rÃ¨gles ? â†’ livemodel.py<br>
        âœ… Bug d'affichage ? â†’ liveview.py<br>
        âœ… Bug d'Ã©vÃ©nement ? â†’ livecontroller.py
    </td>
</tr>
<tr>
    <td><strong>Travailler en Ã©quipe</strong></td>
    <td>
        âŒ Un seul fichier<br>
        âŒ Conflits Git constants<br>
        âŒ Impossible de parallÃ©liser
    </td>
    <td>
        âœ… Alice travaille sur livemodel.py<br>
        âœ… Bob travaille sur liveview.py<br>
        âœ… Pas de conflits
    </td>
</tr>
</table>
</div>

<h3 id="comp-conclusion">10.5. Conclusion de la comparaison</h3>

<div class="important">
<strong>Version ProcÃ©durale - Avantages :</strong>
<ul>
    <li>âœ… Simple pour de TRÃˆS petits projets</li>
    <li>âœ… Moins de lignes de code (mais code moins organisÃ©)</li>
    <li>âœ… DÃ©marrage rapide</li>
</ul>

<strong>Version ProcÃ©durale - InconvÃ©nients :</strong>
<ul>
    <li>âŒ Code spaghetti (tout est mÃ©langÃ©)</li>
    <li>âŒ Variables globales dangereuses</li>
    <li>âŒ Difficile Ã  tester</li>
    <li>âŒ Difficile Ã  maintenir</li>
    <li>âŒ Difficile Ã  Ã©tendre</li>
    <li>âŒ Erreurs conceptuelles (indices/pixels)</li>
    <li>âŒ Impossible de rÃ©utiliser des parties</li>
</ul>
</div>

<div class="important">
<strong>Version OOP - Avantages :</strong>
<ul>
    <li>âœ… Code organisÃ© et modulaire</li>
    <li>âœ… SÃ©paration des responsabilitÃ©s (MVC)</li>
    <li>âœ… Testable sans interface graphique</li>
    <li>âœ… Facile Ã  maintenir (chaque fichier a un rÃ´le)</li>
    <li>âœ… Facile Ã  Ã©tendre (Design Patterns)</li>
    <li>âœ… RÃ©utilisable (composants indÃ©pendants)</li>
    <li>âœ… Travail en Ã©quipe facilitÃ©</li>
    <li>âœ… Correction conceptuelle (indices vs pixels)</li>
</ul>

<strong>Version OOP - InconvÃ©nients :</strong>
<ul>
    <li>âŒ Plus de code Ã  Ã©crire initialement</li>
    <li>âŒ Courbe d'apprentissage (Design Patterns)</li>
    <li>âŒ Peut Ãªtre "overkill" pour des micro-projets</li>
</ul>
</div>

<div class="concept">
<strong>Verdict final :</strong>
<p>
Pour un projet comme le Game of Life (complexitÃ© moyenne, Ã©volution future probable, travail d'Ã©quipe, besoin de tests), la <strong>version OOP est LARGEMENT supÃ©rieure</strong>.
</p>
<p>
Le surcoÃ»t initial en termes de lignes de code est largement compensÃ© par :
</p>
<ul>
    <li>La qualitÃ© du code</li>
    <li>La maintenabilitÃ© Ã  long terme</li>
    <li>La facilitÃ© de test</li>
    <li>La possibilitÃ© d'Ã©volution</li>
    <li>L'apprentissage des bonnes pratiques professionnelles</li>
</ul>
</div>

<!-- ================================================================== -->
<!-- CONCLUSION GÃ‰NÃ‰RALE                                              -->
<!-- ================================================================== -->

<h2 id="conclusion">CONCLUSION GÃ‰NÃ‰RALE</h2>

<div class="concept">
<strong>Ce que nous avons appris :</strong>

<h3>1. Architecture MVC</h3>
<ul>
    <li>SÃ©paration claire entre Model (logique), View (prÃ©sentation) et Controller (coordination)</li>
    <li>Chaque composant a sa responsabilitÃ© et ne fait QUE Ã§a</li>
    <li>Facilite la maintenance et l'Ã©volution</li>
</ul>

<h3>2. Design Patterns</h3>
<ul>
    <li><strong>Observer :</strong> Notification automatique des changements</li>
    <li><strong>Strategy :</strong> Algorithmes interchangeables</li>
    <li><strong>Singleton :</strong> Instance unique (avec prÃ©cautions)</li>
    <li><strong>Iterator :</strong> Parcours Ã©lÃ©gant des collections</li>
</ul>

<h3>3. Principes OOP</h3>
<ul>
    <li><strong>Encapsulation :</strong> Attributs privÃ©s, interface publique</li>
    <li><strong>Abstraction :</strong> Interfaces ABC dÃ©finissent les contrats</li>
    <li><strong>Composition :</strong> "Has-a" prÃ©fÃ©rÃ© Ã  "Is-a"</li>
    <li><strong>Polymorphisme :</strong> Code gÃ©nÃ©rique via interfaces communes</li>
</ul>

<h3>4. Bonnes pratiques Python</h3>
<ul>
    <li>Properties (@property) pour l'encapsulation</li>
    <li>GÃ©nÃ©rateurs (yield) pour l'efficacitÃ© mÃ©moire</li>
    <li>ABC pour les classes abstraites</li>
    <li>Conventions de nommage (__private, public)</li>
</ul>

<h3>5. Corrections conceptuelles</h3>
<ul>
    <li>SÃ©paration indices (Model) vs pixels (View)</li>
    <li>Division entiÃ¨re (//) vs modulo (%) pour conversion</li>
    <li>Calcul des nouveaux Ã©tats AVANT application (evolve)</li>
    <li>Ã‚ge des cellules basÃ© sur transitions d'Ã©tat</li>
</ul>
</div>

<div class="important">
<strong>QualitÃ©s professionnelles dÃ©montrÃ©es dans ce projet :</strong>
<ul>
    <li>âœ… MaÃ®trise de l'architecture MVC</li>
    <li>âœ… Application correcte des Design Patterns</li>
    <li>âœ… Respect des principes SOLID</li>
    <li>âœ… Code maintenable et extensible</li>
    <li>âœ… Documentation claire et pÃ©dagogique</li>
    <li>âœ… SÃ©paration des responsabilitÃ©s</li>
    <li>âœ… TestabilitÃ© (Model indÃ©pendant de la View)</li>
</ul>
</div>

<div class="concept">
<p style="text-align: center; font-size: 1.2em; margin-top: 30px;">
<strong>ğŸ“ Projet Q54 - Conway's Game of Life</strong><br>
<em>De la programmation procÃ©durale Ã  l'excellence en Programmation OrientÃ©e Objet</em>
</p>
</div>

</body>
</html>
